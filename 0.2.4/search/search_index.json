{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Photoshop Integration","text":""},{"location":"index.html#implemented-features","title":"Implemented features","text":"<ul> <li>publishing workfile</li> <li>publishing image product type</li> <li>for each layer</li> <li>for all visible layers altogether</li> <li>loading image/image sequences</li> <li>referencing image</li> <li>manage version of loaded containers</li> </ul>"},{"location":"index.html#setup","title":"Setup","text":"<p>The Photoshop integration requires two components to work; <code>extension</code> and <code>server</code>.</p>"},{"location":"index.html#extension","title":"Extension","text":"<p>There need to be done several setup steps first before running the AYON integration. First your active project need to have Photoshop (PS) defined in the project anatomy as an available tool including its filepath to the executable (being set by default). Secondly its neccessary to install PS extension manager which simplifies future extensions installation / management for PS. We skip the first step due to the fact it should be already preset by TD / Admin. And we jump to the second step instead right away.</p> <p>To install the extension manager , open the following link and download it first Anastasyi's Extension Manager. Open Anastasyi's Extension Manager and select Photoshop in the menu. Then go to {path to PS addon}hosts/photoshop/api/extension.zxp. Current location will be most likely in /User/AppData, on WINDOWS it would be something like c:\\Users\\YOUR_USER\\AppData\\Local\\Ynput\\AYON\\addons\\core_xx.xx.xx\\ayon_core\\hosts\\photoshop\\api. On Linux look in ~/.local/share/Ynput/AYON/addons, on Mac ~/Library/Application Support/Ynput/AYON/addons</p>"},{"location":"index.html#server","title":"Server","text":"<p>The easiest way to get the server and Photoshop launch is with:</p> <pre><code>python -c ^\"import ayon_photoshop;ayon_photoshop.launch(\"\"C:\\Program Files\\Adobe\\Adobe Photoshop 2024\\Photoshop.exe\"\")^\"\n</code></pre> <p><code>ayon_photoshop.launch</code> launches the application and server, and also closes the server when Photoshop exists.</p>"},{"location":"index.html#usage","title":"Usage","text":"<p>The Photoshop extension can be found under <code>Window &gt; Extensions &gt; Ayon</code>. Once launched you should be presented with a panel like this:</p> <p></p>"},{"location":"index.html#developing","title":"Developing","text":""},{"location":"index.html#extension_1","title":"Extension","text":"<p>When developing the extension you can load it unsigned.</p> <p>When signing the extension you can use this guide.</p> <pre><code>ZXPSignCmd -selfSignedCert NA NA Ayon Ayon-Photoshop Ayon extension.p12\nZXPSignCmd -sign {path to ayon-photoshop}\\client\\ayon-photoshop\\api\\extension {path to ayon-photoshop}\\client\\ayon-photoshop\\api\\extension.zxp extension.p12 ayon\n</code></pre>"},{"location":"index.html#plugin-examples","title":"Plugin Examples","text":"<p>These plugins were made with the polly config. To fully integrate and load, you will have to use this config and add <code>image</code> to the integration plugin.</p> <p>For easier debugging of Javascript: https://community.adobe.com/t5/download-install/adobe-extension-debuger-problem/td-p/10911704?page=1 Add --enable-blink-features=ShadowDOMV0,CustomElementsV0 when starting Chrome then localhost:8078 (port set in <code>ayon-photoshop}\\client\\ayon-photoshop\\api\\.debug</code>)</p> <p>Or use Visual Studio Code https://medium.com/adobetech/extendscript-debugger-for-visual-studio-code-public-release-a2ff6161fa01</p> <p>Or install CEF client from https://github.com/Adobe-CEP/CEP-Resources/tree/master/CEP_9.x</p>"},{"location":"index.html#resources","title":"Resources","text":"<ul> <li>https://github.com/lohriialo/photoshop-scripting-python</li> <li>https://www.adobe.com/devnet/photoshop/scripting.html</li> <li>https://github.com/Adobe-CEP/Getting-Started-guides</li> <li>https://github.com/Adobe-CEP/CEP-Resources</li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_photoshop<ul> <li>addon</li> <li>api<ul> <li>launch_logic</li> <li>launch_script</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>webserver</li> <li>ws_stub</li> </ul> </li> <li>hooks<ul> <li>pre_launch_args</li> </ul> </li> <li>lib</li> <li>plugins<ul> <li>create<ul> <li>create_flatten_image</li> <li>create_image</li> <li>create_review</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_image</li> <li>load_image_from_sequence</li> <li>load_reference</li> </ul> </li> <li>publish<ul> <li>closePS</li> <li>collect_auto_image</li> <li>collect_auto_image_refresh</li> <li>collect_auto_review</li> <li>collect_auto_workfile</li> <li>collect_batch_data</li> <li>collect_color_coded_instances</li> <li>collect_current_file</li> <li>collect_extension_version</li> <li>collect_image</li> <li>collect_published_version</li> <li>collect_review</li> <li>collect_version</li> <li>collect_workfile</li> <li>extract_image</li> <li>extract_review</li> <li>extract_save_scene</li> <li>increment_workfile</li> <li>validate_instance_asset</li> <li>validate_naming</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>creator_plugins</li> <li>imageio</li> <li>main</li> <li>publish_plugins</li> <li>workfile_builder</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_photoshop/index.html","title":"ayon_photoshop","text":""},{"location":"autoapi/client/ayon_photoshop/index.html#client.ayon_photoshop.PhotoshopAddon","title":"<code>PhotoshopAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_photoshop/addon.py</code> <pre><code>class PhotoshopAddon(AYONAddon, IHostAddon):\n    name = \"photoshop\"\n    version = __version__\n    host_name = \"photoshop\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"WEBSOCKET_URL\": \"ws://localhost:8099/ws/\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_workfile_extensions(self):\n        return [\".psd\", \".psb\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(PHOTOSHOP_ADDON_ROOT, \"hooks\")\n        ]\n\n    def publish_in_test(self, log, close_plugin_name=None):\n        \"\"\"Runs publish in an opened host with a context.\n        Close Python process at the end.\n        \"\"\"\n\n        from ayon_photoshop.api.lib import publish_in_test\n\n        publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/index.html#client.ayon_photoshop.PhotoshopAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_photoshop/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"WEBSOCKET_URL\": \"ws://localhost:8099/ws/\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/index.html#client.ayon_photoshop.PhotoshopAddon.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Runs publish in an opened host with a context. Close Python process at the end.</p> Source code in <code>client/ayon_photoshop/addon.py</code> <pre><code>def publish_in_test(self, log, close_plugin_name=None):\n    \"\"\"Runs publish in an opened host with a context.\n    Close Python process at the end.\n    \"\"\"\n\n    from ayon_photoshop.api.lib import publish_in_test\n\n    publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_photoshop/addon.html#client.ayon_photoshop.addon.PhotoshopAddon","title":"<code>PhotoshopAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_photoshop/addon.py</code> <pre><code>class PhotoshopAddon(AYONAddon, IHostAddon):\n    name = \"photoshop\"\n    version = __version__\n    host_name = \"photoshop\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"WEBSOCKET_URL\": \"ws://localhost:8099/ws/\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_workfile_extensions(self):\n        return [\".psd\", \".psb\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(PHOTOSHOP_ADDON_ROOT, \"hooks\")\n        ]\n\n    def publish_in_test(self, log, close_plugin_name=None):\n        \"\"\"Runs publish in an opened host with a context.\n        Close Python process at the end.\n        \"\"\"\n\n        from ayon_photoshop.api.lib import publish_in_test\n\n        publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/addon.html#client.ayon_photoshop.addon.PhotoshopAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_photoshop/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"WEBSOCKET_URL\": \"ws://localhost:8099/ws/\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/addon.html#client.ayon_photoshop.addon.PhotoshopAddon.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Runs publish in an opened host with a context. Close Python process at the end.</p> Source code in <code>client/ayon_photoshop/addon.py</code> <pre><code>def publish_in_test(self, log, close_plugin_name=None):\n    \"\"\"Runs publish in an opened host with a context.\n    Close Python process at the end.\n    \"\"\"\n\n    from ayon_photoshop.api.lib import publish_in_test\n\n    publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_photoshop/lib.html#client.ayon_photoshop.lib.PSAutoCreator","title":"<code>PSAutoCreator</code>","text":"<p>               Bases: <code>AutoCreator</code></p> <p>Generic autocreator to extend.</p> Source code in <code>client/ayon_photoshop/lib.py</code> <pre><code>class PSAutoCreator(AutoCreator):\n    \"\"\"Generic autocreator to extend.\"\"\"\n    def get_instance_attr_defs(self):\n        return []\n\n    def collect_instances(self):\n        for instance_data in cache_and_get_instances(self):\n            creator_id = instance_data.get(\"creator_identifier\")\n\n            if creator_id == self.identifier:\n                instance = CreatedInstance.from_existing(\n                    instance_data, self\n                )\n                self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        self.log.debug(\"update_list:: {}\".format(update_list))\n        for created_inst, _changes in update_list:\n            api.stub().imprint(created_inst.get(\"instance_id\"),\n                               created_inst.data_to_store())\n\n    def create(self, options=None):\n        existing_instance = None\n        for instance in self.create_context.instances:\n            if instance.product_type == self.product_type:\n                existing_instance = instance\n                break\n\n        context = self.create_context\n        project_name = context.get_current_project_name()\n        folder_path = context.get_current_folder_path()\n        task_name = context.get_current_task_name()\n        host_name = context.host_name\n\n        if existing_instance is None:\n            existing_instance_folder = None\n        else:\n            existing_instance_folder = existing_instance[\"folderPath\"]\n\n        if existing_instance is None:\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name, folder_path\n            )\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], task_name\n            )\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": self.default_variant\n            }\n            data.update(self.get_dynamic_data(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n                None\n            ))\n\n            if not self.active_on_create:\n                data[\"active\"] = False\n\n            new_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(new_instance)\n            api.stub().imprint(new_instance.get(\"instance_id\"),\n                               new_instance.data_to_store())\n\n        elif (\n            existing_instance_folder != folder_path\n            or existing_instance[\"task\"] != task_name\n        ):\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name, folder_path\n            )\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], task_name\n            )\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n            )\n            existing_instance[\"folderPath\"] = folder_path\n            existing_instance[\"task\"] = task_name\n            existing_instance[\"productName\"] = product_name\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/lib.html#client.ayon_photoshop.lib.clean_product_name","title":"<code>clean_product_name(product_name)</code>","text":"<p>Clean all variants leftover {layer} from product name.</p> Source code in <code>client/ayon_photoshop/lib.py</code> <pre><code>def clean_product_name(product_name):\n    \"\"\"Clean all variants leftover {layer} from product name.\"\"\"\n    dynamic_data = prepare_template_data({\"layer\": \"{layer}\"})\n    for value in dynamic_data.values():\n        if value in product_name:\n            product_name = (\n                product_name\n                .replace(value, \"\")\n                .replace(\"__\", \"_\")\n                .replace(\"..\", \".\")\n            )\n    # clean trailing separator as Main_\n    pattern = r'[\\W_]+$'\n    replacement = ''\n    return re.sub(pattern, replacement, product_name)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/version.html","title":"version","text":"<p>Package declaring AYON addon 'photoshop' version.</p>"},{"location":"autoapi/client/ayon_photoshop/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.PhotoshopHost","title":"<code>PhotoshopHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>class PhotoshopHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"photoshop\"\n\n    def install(self):\n        \"\"\"Install Photoshop-specific functionality needed for integration.\n\n        This function is called automatically on calling\n        `api.install(photoshop)`.\n        \"\"\"\n        log.info(\"Installing OpenPype Photoshop...\")\n        pyblish.api.register_host(\"photoshop\")\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        register_event_callback(\"application.launched\", on_application_launch)\n\n    def current_file(self):\n        try:\n            full_name = lib.stub().get_active_document_full_name()\n            if full_name and full_name != \"null\":\n                return os.path.normpath(full_name).replace(\"\\\\\", \"/\")\n        except Exception:\n            pass\n\n        return None\n\n    def work_root(self, session):\n        return os.path.normpath(session[\"AYON_WORKDIR\"]).replace(\"\\\\\", \"/\")\n\n    def open_workfile(self, filepath):\n        lib.stub().open(filepath)\n\n        return True\n\n    def save_workfile(self, filepath=None):\n        _, ext = os.path.splitext(filepath)\n        lib.stub().saveAs(filepath, ext[1:], True)\n\n    def get_current_workfile(self):\n        return self.current_file()\n\n    def workfile_has_unsaved_changes(self):\n        if self.current_file():\n            return not lib.stub().is_saved()\n\n        return False\n\n    def get_workfile_extensions(self):\n        return [\".psd\", \".psb\"]\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        \"\"\"Get stored values for context (validation enable/disable etc)\"\"\"\n        meta = _get_stub().get_layers_metadata()\n        for item in meta:\n            if item.get(\"id\") == \"publish_context\":\n                item.pop(\"id\")\n                return item\n\n        return {}\n\n    def update_context_data(self, data, changes):\n        \"\"\"Store value needed for context\"\"\"\n        item = data\n        item[\"id\"] = \"publish_context\"\n        _get_stub().imprint(item[\"id\"], item)\n\n    def list_instances(self):\n        \"\"\"List all created instances to publish from current workfile.\n\n        Pulls from File &gt; File Info\n\n        Returns:\n            (list) of dictionaries matching instances format\n        \"\"\"\n        stub = _get_stub()\n\n        if not stub:\n            return []\n\n        instances = []\n        layers_meta = stub.get_layers_metadata()\n        if layers_meta:\n            for instance in layers_meta:\n                if instance.get(\"id\") in {\n                    AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n                }:\n                    instances.append(instance)\n\n        return instances\n\n    def remove_instance(self, instance):\n        \"\"\"Remove instance from current workfile metadata.\n\n        Updates metadata of current file in File &gt; File Info and removes\n        icon highlight on group layer.\n\n        Args:\n            instance (dict): instance representation from subsetmanager model\n        \"\"\"\n        stub = _get_stub()\n\n        if not stub:\n            return\n\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n        if not inst_id:\n            log.warning(\"No instance identifier for {}\".format(instance))\n            return\n\n        stub.remove_instance(inst_id)\n\n        if instance.get(\"members\"):\n            item = stub.get_layer(instance[\"members\"][0])\n            if item:\n                stub.rename_layer(item.id,\n                                  item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.PhotoshopHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Get stored values for context (validation enable/disable etc)</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def get_context_data(self):\n    \"\"\"Get stored values for context (validation enable/disable etc)\"\"\"\n    meta = _get_stub().get_layers_metadata()\n    for item in meta:\n        if item.get(\"id\") == \"publish_context\":\n            item.pop(\"id\")\n            return item\n\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.PhotoshopHost.install","title":"<code>install()</code>","text":"<p>Install Photoshop-specific functionality needed for integration.</p> <p>This function is called automatically on calling <code>api.install(photoshop)</code>.</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install Photoshop-specific functionality needed for integration.\n\n    This function is called automatically on calling\n    `api.install(photoshop)`.\n    \"\"\"\n    log.info(\"Installing OpenPype Photoshop...\")\n    pyblish.api.register_host(\"photoshop\")\n\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    register_event_callback(\"application.launched\", on_application_launch)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.PhotoshopHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances to publish from current workfile.</p> <p>Pulls from File &gt; File Info</p> <p>Returns:</p> Type Description <p>(list) of dictionaries matching instances format</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances to publish from current workfile.\n\n    Pulls from File &gt; File Info\n\n    Returns:\n        (list) of dictionaries matching instances format\n    \"\"\"\n    stub = _get_stub()\n\n    if not stub:\n        return []\n\n    instances = []\n    layers_meta = stub.get_layers_metadata()\n    if layers_meta:\n        for instance in layers_meta:\n            if instance.get(\"id\") in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                instances.append(instance)\n\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.PhotoshopHost.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance from current workfile metadata.</p> <p>Updates metadata of current file in File &gt; File Info and removes icon highlight on group layer.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>dict</code> <p>instance representation from subsetmanager model</p> required Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def remove_instance(self, instance):\n    \"\"\"Remove instance from current workfile metadata.\n\n    Updates metadata of current file in File &gt; File Info and removes\n    icon highlight on group layer.\n\n    Args:\n        instance (dict): instance representation from subsetmanager model\n    \"\"\"\n    stub = _get_stub()\n\n    if not stub:\n        return\n\n    inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n    if not inst_id:\n        log.warning(\"No instance identifier for {}\".format(instance))\n        return\n\n    stub.remove_instance(inst_id)\n\n    if instance.get(\"members\"):\n        item = stub.get_layer(instance[\"members\"][0])\n        if item:\n            stub.rename_layer(item.id,\n                              item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.PhotoshopHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Store value needed for context</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def update_context_data(self, data, changes):\n    \"\"\"Store value needed for context\"\"\"\n    item = data\n    item[\"id\"] = \"publish_context\"\n    _get_stub().imprint(item[\"id\"], item)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.containerise","title":"<code>containerise(name, namespace, layer, context, loader=None, suffix='_CON')</code>","text":"<p>Imprint layer with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>layer</code> <code>PSItem</code> <p>Layer to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'_CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def containerise(\n    name, namespace, layer, context, loader=None, suffix=\"_CON\"\n):\n    \"\"\"Imprint layer with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        layer (PSItem): Layer to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n    \"\"\"\n    layer.name = name + suffix\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"members\": [str(layer.id)]\n    }\n    stub = lib.stub()\n    stub.imprint(layer.id, data)\n\n    return layer\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.get_unique_layer_name","title":"<code>get_unique_layer_name(layers, container_name, product_name)</code>","text":"<p>Prepare unique layer name.</p> <p>Gets all layer names and if '_' is present, it adds suffix '1', or increases the suffix by 1. <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> required <code>product_name</code> <code>str</code> required <p>Returns:</p> Name Type Description <code>str</code> <p>name_00X (without version)</p> Source code in <code>client/ayon_photoshop/api/plugin.py</code> <pre><code>def get_unique_layer_name(layers, container_name, product_name):\n    \"\"\"Prepare unique layer name.\n\n    Gets all layer names and if '&lt;container_name&gt;_&lt;product_name&gt;' is present,\n    it adds suffix '1', or increases the suffix by 1.\n\n    Args:\n        layers (list) of dict with layers info (name, id etc.)\n        container_name (str):\n        product_name (str):\n\n    Returns:\n        str: name_00X (without version)\n    \"\"\"\n    name = \"{}_{}\".format(container_name, product_name)\n    names = {}\n    for layer in layers:\n        layer_name = re.sub(r'_\\d{3}$', '', layer.name)\n        if layer_name in names.keys():\n            names[layer_name] = names[layer_name] + 1\n        else:\n            names[layer_name] = 1\n    occurrences = names.get(name, 0)\n\n    return \"{}_{:0&gt;3d}\".format(name, occurrences + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active Photoshop document</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Photoshop; once loaded they are called 'containers'</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active Photoshop document\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Photoshop; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    try:\n        stub = lib.stub()  # only after Photoshop is up\n    except lib.ConnectionNotEstablishedYet:\n        print(\"Not connected yet, ignoring\")\n        return\n\n    if not stub.get_active_document_name():\n        return\n\n    layers_meta = stub.get_layers_metadata()  # minimalize calls to PS\n    for layer in stub.get_layers():\n        data = stub.read(layer, layers_meta)\n\n        # Skip non-tagged layers.\n        if not data:\n            continue\n\n        # Filter to only containers.\n        if \"container\" not in data[\"id\"]:\n            continue\n\n        # Append transient data\n        data[\"objectName\"] = layer.name.replace(stub.LOADED_ICON, '')\n        data[\"layer\"] = layer\n\n        yield data\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_photoshop/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n    selection = stub().get_selected_layers()\n    try:\n        yield selection\n    finally:\n        stub().select_layers(selection)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.maintained_visibility","title":"<code>maintained_visibility(layers=None)</code>","text":"<p>Maintain visibility during context.</p> Source code in <code>client/ayon_photoshop/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_visibility(layers=None):\n    \"\"\"Maintain visibility during context.\n\n    Args:\n        layers (list) of PSItem (used for caching)\n    \"\"\"\n    visibility = {}\n    if not layers:\n        layers = stub().get_layers()\n    for layer in layers:\n        visibility[layer.id] = layer.visible\n    try:\n        yield\n    finally:\n        for layer in layers:\n            stub().set_visible(layer.id, visibility[layer.id])\n            pass\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/index.html#client.ayon_photoshop.api.stub","title":"<code>stub()</code>","text":"<pre><code>Convenience function to get server RPC stub to call methods directed\nfor host (Photoshop).\nIt expects already created connection, started from client.\nCurrently created when panel is opened (PS: Window&gt;Extensions&gt;Avalon)\n</code></pre> <p>:return:  where functions could be called from Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>def stub():\n    \"\"\"\n        Convenience function to get server RPC stub to call methods directed\n        for host (Photoshop).\n        It expects already created connection, started from client.\n        Currently created when panel is opened (PS: Window&gt;Extensions&gt;Avalon)\n    :return: &lt;PhotoshopClientStub&gt; where functions could be called from\n    \"\"\"\n    ps_stub = PhotoshopServerStub()\n    if not ps_stub.client:\n        raise ConnectionNotEstablishedYet(\"Connection is not created yet\")\n\n    return ps_stub\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html","title":"launch_logic","text":""},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.MainThreadItem","title":"<code>MainThreadItem</code>","text":"<p>Structure to store information about callback in main thread.</p> <p>Item should be used to execute callback in main thread which may be needed for execution of Qt objects.</p> <p>Item store callback (callable variable), arguments and keyword arguments for the callback. Item hold information about it's process.</p> Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>class MainThreadItem:\n    \"\"\"Structure to store information about callback in main thread.\n\n    Item should be used to execute callback in main thread which may be needed\n    for execution of Qt objects.\n\n    Item store callback (callable variable), arguments and keyword arguments\n    for the callback. Item hold information about it's process.\n    \"\"\"\n    not_set = object()\n\n    def __init__(self, callback, *args, **kwargs):\n        self._done = False\n        self._exception = self.not_set\n        self._result = self.not_set\n        self._callback = callback\n        self._args = args\n        self._kwargs = kwargs\n\n    @property\n    def done(self):\n        return self._done\n\n    @property\n    def exception(self):\n        return self._exception\n\n    @property\n    def result(self):\n        return self._result\n\n    def execute(self):\n        \"\"\"Execute callback and store its result.\n\n        Method must be called from main thread. Item is marked as `done`\n        when callback execution finished. Store output of callback of exception\n        information when callback raises one.\n        \"\"\"\n        log.debug(\"Executing process in main thread\")\n        if self.done:\n            log.warning(\"- item is already processed\")\n            return\n\n        log.info(\"Running callback: {}\".format(str(self._callback)))\n        try:\n            result = self._callback(*self._args, **self._kwargs)\n            self._result = result\n\n        except Exception as exc:\n            self._exception = exc\n\n        finally:\n            self._done = True\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.MainThreadItem.execute","title":"<code>execute()</code>","text":"<p>Execute callback and store its result.</p> <p>Method must be called from main thread. Item is marked as <code>done</code> when callback execution finished. Store output of callback of exception information when callback raises one.</p> Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>def execute(self):\n    \"\"\"Execute callback and store its result.\n\n    Method must be called from main thread. Item is marked as `done`\n    when callback execution finished. Store output of callback of exception\n    information when callback raises one.\n    \"\"\"\n    log.debug(\"Executing process in main thread\")\n    if self.done:\n        log.warning(\"- item is already processed\")\n        return\n\n    log.info(\"Running callback: {}\".format(str(self._callback)))\n    try:\n        result = self._callback(*self._args, **self._kwargs)\n        self._result = result\n\n    except Exception as exc:\n        self._exception = exc\n\n    finally:\n        self._done = True\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.PhotoshopRoute","title":"<code>PhotoshopRoute</code>","text":"<p>               Bases: <code>WebSocketRoute</code></p> <p>One route, mimicking external application (like Harmony, etc). All functions could be called from client. 'do_notify' function calls function on the client - mimicking     notification after long running job on the server or similar</p> Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>class PhotoshopRoute(WebSocketRoute):\n    \"\"\"\n        One route, mimicking external application (like Harmony, etc).\n        All functions could be called from client.\n        'do_notify' function calls function on the client - mimicking\n            notification after long running job on the server or similar\n    \"\"\"\n    instance = None\n\n    def init(self, **kwargs):\n        # Python __init__ must be return \"self\".\n        # This method might return anything.\n        log.debug(\"someone called Photoshop route\")\n        self.instance = self\n        return kwargs\n\n    # server functions\n    async def ping(self):\n        log.debug(\"someone called Photoshop route ping\")\n\n    # This method calls function on the client side\n    # client functions\n    async def set_context(self, project, folder, task):\n        \"\"\"\n            Sets 'project' and 'folder' to envs, eg. setting context.\n\n        Opens last workile from that context if exists.\n\n        Args:\n            project (str)\n            folder (str)\n            task (str\n        \"\"\"\n        log.info(\"Setting context change\")\n        log.info(f\"project {project} folder {folder} task {task}\")\n\n        folder_entity = ayon_api.get_folder_by_path(project, folder)\n        task_entity = ayon_api.get_task_by_name(\n            project, folder_entity[\"id\"], task\n        )\n        change_current_context(folder_entity, task_entity)\n\n        last_workfile_path = self._get_last_workfile_path(project,\n                                                          folder,\n                                                          task)\n        if last_workfile_path and os.path.exists(last_workfile_path):\n            ProcessLauncher.execute_in_main_thread(\n                lambda: stub().open(last_workfile_path))\n\n\n    async def read(self):\n        log.debug(\"photoshop.read client calls server server calls \"\n                  \"photoshop client\")\n        return await self.socket.call('photoshop.read')\n\n    # panel routes for tools\n    async def workfiles_route(self):\n        self._tool_route(\"workfiles\")\n\n    async def loader_route(self):\n        self._tool_route(\"loader\")\n\n    async def publish_route(self):\n        self._tool_route(\"publisher\")\n\n    async def sceneinventory_route(self):\n        self._tool_route(\"sceneinventory\")\n\n    async def experimental_tools_route(self):\n        self._tool_route(\"experimental_tools\")\n\n    def _tool_route(self, _tool_name):\n        \"\"\"The address accessed when clicking on the buttons.\"\"\"\n\n        ProcessLauncher.execute_in_main_thread(show_tool_by_name, _tool_name)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def _get_last_workfile_path(self, project_name, folder_path, task_name):\n        \"\"\"Returns last workfile path if exists\"\"\"\n        host = registered_host()\n        host_name = \"photoshop\"\n        template_key = get_workfile_template_key_from_context(\n            project_name,\n            folder_path,\n            task_name,\n            host_name,\n        )\n        anatomy = Anatomy(project_name)\n\n        data = get_template_data_with_names(\n            project_name, folder_path, task_name, host_name\n        )\n        data[\"root\"] = anatomy.roots\n\n        work_template = anatomy.get_template_item(\"work\", template_key)\n\n        # Define saving file extension\n        extensions = host.get_workfile_extensions()\n\n        work_root = work_template[\"directory\"].format_strict(data)\n        file_template = work_template[\"file\"].template\n        last_workfile_path = get_last_workfile(\n            work_root, file_template, data, extensions, True\n        )\n\n        return last_workfile_path\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.PhotoshopRoute.set_context","title":"<code>set_context(project, folder, task)</code>  <code>async</code>","text":"<pre><code>Sets 'project' and 'folder' to envs, eg. setting context.\n</code></pre> <p>Opens last workile from that context if exists.</p> Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>async def set_context(self, project, folder, task):\n    \"\"\"\n        Sets 'project' and 'folder' to envs, eg. setting context.\n\n    Opens last workile from that context if exists.\n\n    Args:\n        project (str)\n        folder (str)\n        task (str\n    \"\"\"\n    log.info(\"Setting context change\")\n    log.info(f\"project {project} folder {folder} task {task}\")\n\n    folder_entity = ayon_api.get_folder_by_path(project, folder)\n    task_entity = ayon_api.get_task_by_name(\n        project, folder_entity[\"id\"], task\n    )\n    change_current_context(folder_entity, task_entity)\n\n    last_workfile_path = self._get_last_workfile_path(project,\n                                                      folder,\n                                                      task)\n    if last_workfile_path and os.path.exists(last_workfile_path):\n        ProcessLauncher.execute_in_main_thread(\n            lambda: stub().open(last_workfile_path))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.ProcessLauncher","title":"<code>ProcessLauncher</code>","text":"<p>               Bases: <code>QObject</code></p> Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>class ProcessLauncher(QtCore.QObject):\n    route_name = \"Photoshop\"\n    _main_thread_callbacks = collections.deque()\n\n    def __init__(self, subprocess_args):\n        self._subprocess_args = subprocess_args\n        self._log = None\n\n        super(ProcessLauncher, self).__init__()\n\n        # Keep track if launcher was already started\n        self._started = False\n\n        self._process = None\n        self._websocket_server = None\n\n        start_process_timer = QtCore.QTimer()\n        start_process_timer.setInterval(100)\n\n        loop_timer = QtCore.QTimer()\n        loop_timer.setInterval(200)\n\n        start_process_timer.timeout.connect(self._on_start_process_timer)\n        loop_timer.timeout.connect(self._on_loop_timer)\n\n        self._start_process_timer = start_process_timer\n        self._loop_timer = loop_timer\n\n    @property\n    def log(self):\n        if self._log is None:\n            self._log = Logger.get_logger(\n                \"{}-launcher\".format(self.route_name)\n            )\n        return self._log\n\n    @property\n    def websocket_server_is_running(self):\n        if self._websocket_server is not None:\n            return self._websocket_server.is_running\n        return False\n\n    @property\n    def is_process_running(self):\n        if self._process is not None:\n            return self._process.poll() is None\n        return False\n\n    @property\n    def is_host_connected(self):\n        \"\"\"Returns True if connected, False if app is not running at all.\"\"\"\n        if not self.is_process_running:\n            return False\n\n        try:\n            _stub = stub()\n            if _stub:\n                return True\n        except Exception:\n            pass\n\n        return None\n\n    @classmethod\n    def execute_in_main_thread(cls, callback, *args, **kwargs):\n        item = MainThreadItem(callback, *args, **kwargs)\n        cls._main_thread_callbacks.append(item)\n        return item\n\n    def start(self):\n        if self._started:\n            return\n        self.log.info(\"Started launch logic of Photoshop\")\n        self._started = True\n        self._start_process_timer.start()\n\n    def exit(self):\n        \"\"\" Exit whole application. \"\"\"\n        if self._start_process_timer.isActive():\n            self._start_process_timer.stop()\n        if self._loop_timer.isActive():\n            self._loop_timer.stop()\n\n        if self._websocket_server is not None:\n            self._websocket_server.stop()\n\n        if self._process:\n            self._process.kill()\n            self._process.wait()\n\n        QtCore.QCoreApplication.exit()\n\n    def _on_loop_timer(self):\n        # TODO find better way and catch errors\n        # Run only callbacks that are in queue at the moment\n        cls = self.__class__\n        for _ in range(len(cls._main_thread_callbacks)):\n            if cls._main_thread_callbacks:\n                item = cls._main_thread_callbacks.popleft()\n                item.execute()\n\n        if not self.is_process_running:\n            self.log.info(\"Host process is not running. Closing\")\n            self.exit()\n\n        elif not self.websocket_server_is_running:\n            self.log.info(\"Websocket server is not running. Closing\")\n            self.exit()\n\n    def _on_start_process_timer(self):\n        # TODO add try except validations for each part in this method\n        # Start server as first thing\n        if self._websocket_server is None:\n            self._init_server()\n            return\n\n        # TODO add waiting time\n        # Wait for webserver\n        if not self.websocket_server_is_running:\n            return\n\n        # Start application process\n        if self._process is None:\n            self._start_process()\n            self.log.info(\"Waiting for host to connect\")\n            return\n\n        # TODO add waiting time\n        # Wait until host is connected\n        if self.is_host_connected:\n            self._start_process_timer.stop()\n            self._loop_timer.start()\n        elif (\n            not self.is_process_running\n            or not self.websocket_server_is_running\n        ):\n            self.exit()\n\n    def _init_server(self):\n        if self._websocket_server is not None:\n            return\n\n        self.log.debug(\n            \"Initialization of websocket server for host communication\"\n        )\n\n        self._websocket_server = websocket_server = WebServerTool()\n        if websocket_server.port_occupied(\n            websocket_server.host_name,\n            websocket_server.port\n        ):\n            self.log.info(\n                \"Server already running, sending actual context and exit.\"\n            )\n            asyncio.run(websocket_server.send_context_change(self.route_name))\n            self.exit()\n            return\n\n        # Add Websocket route\n        websocket_server.add_route(\"*\", \"/ws/\", WebSocketAsync)\n        # Add after effects route to websocket handler\n\n        print(\"Adding {} route\".format(self.route_name))\n        WebSocketAsync.add_route(\n            self.route_name, PhotoshopRoute\n        )\n        self.log.info(\"Starting websocket server for host communication\")\n        websocket_server.start_server()\n\n    def _start_process(self):\n        if self._process is not None:\n            return\n        self.log.info(\"Starting host process\")\n        try:\n            self._process = subprocess.Popen(\n                self._subprocess_args,\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL\n            )\n        except Exception:\n            self.log.info(\"exce\", exc_info=True)\n            self.exit()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.ProcessLauncher.is_host_connected","title":"<code>is_host_connected</code>  <code>property</code>","text":"<p>Returns True if connected, False if app is not running at all.</p>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.ProcessLauncher.exit","title":"<code>exit()</code>","text":"<p>Exit whole application.</p> Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>def exit(self):\n    \"\"\" Exit whole application. \"\"\"\n    if self._start_process_timer.isActive():\n        self._start_process_timer.stop()\n    if self._loop_timer.isActive():\n        self._loop_timer.stop()\n\n    if self._websocket_server is not None:\n        self._websocket_server.stop()\n\n    if self._process:\n        self._process.kill()\n        self._process.wait()\n\n    QtCore.QCoreApplication.exit()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_logic.html#client.ayon_photoshop.api.launch_logic.stub","title":"<code>stub()</code>","text":"<pre><code>Convenience function to get server RPC stub to call methods directed\nfor host (Photoshop).\nIt expects already created connection, started from client.\nCurrently created when panel is opened (PS: Window&gt;Extensions&gt;Avalon)\n</code></pre> <p>:return:  where functions could be called from Source code in <code>client/ayon_photoshop/api/launch_logic.py</code> <pre><code>def stub():\n    \"\"\"\n        Convenience function to get server RPC stub to call methods directed\n        for host (Photoshop).\n        It expects already created connection, started from client.\n        Currently created when panel is opened (PS: Window&gt;Extensions&gt;Avalon)\n    :return: &lt;PhotoshopClientStub&gt; where functions could be called from\n    \"\"\"\n    ps_stub = PhotoshopServerStub()\n    if not ps_stub.client:\n        raise ConnectionNotEstablishedYet(\"Connection is not created yet\")\n\n    return ps_stub\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_script.html","title":"launch_script","text":"<p>Script wraps launch mechanism of Photoshop implementations.</p> <p>Arguments passed to the script are passed to launch function in host implementation. In all cases requires host app executable and may contain workfile or others.</p>"},{"location":"autoapi/client/ayon_photoshop/api/launch_script.html#client.ayon_photoshop.api.launch_script.on_invalid_args","title":"<code>on_invalid_args(script_not_found)</code>","text":"<p>Show to user message box saying that something went wrong.</p> <p>Tell user that arguments to launch implementation are invalid with arguments details.</p> <p>Parameters:</p> Name Type Description Default <code>script_not_found</code> <code>bool</code> <p>Use different message based on this value.</p> required Source code in <code>client/ayon_photoshop/api/launch_script.py</code> <pre><code>def on_invalid_args(script_not_found):\n    \"\"\"Show to user message box saying that something went wrong.\n\n    Tell user that arguments to launch implementation are invalid with\n    arguments details.\n\n    Args:\n        script_not_found (bool): Use different message based on this value.\n    \"\"\"\n\n    title = \"Invalid arguments\"\n    joined_args = \", \".join(\"\\\"{}\\\"\".format(arg) for arg in sys.argv)\n    if script_not_found:\n        submsg = \"Where couldn't find script path:\\n\\\"{}\\\"\"\n    else:\n        submsg = \"Expected Host executable after script path:\\n\\\"{}\\\"\"\n\n    message = \"BUG: Got invalid arguments so can't launch Host application.\"\n    detail_message = \"Process was launched with arguments:\\n{}\\n\\n{}\".format(\n        joined_args,\n        submsg.format(CURRENT_FILE)\n    )\n\n    show_error_messagebox(title, message, detail_message)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/launch_script.html#client.ayon_photoshop.api.launch_script.show_error_messagebox","title":"<code>show_error_messagebox(title, message, detail_message=None)</code>","text":"<p>Function will show message and process ends after closing it.</p> Source code in <code>client/ayon_photoshop/api/launch_script.py</code> <pre><code>def show_error_messagebox(title, message, detail_message=None):\n    \"\"\"Function will show message and process ends after closing it.\"\"\"\n    from qtpy import QtWidgets, QtCore\n    from ayon_core import style\n\n    app = QtWidgets.QApplication([])\n    app.setStyleSheet(style.load_stylesheet())\n\n    msgbox = QtWidgets.QMessageBox()\n    msgbox.setWindowTitle(title)\n    msgbox.setText(message)\n\n    if detail_message:\n        msgbox.setDetailedText(detail_message)\n\n    msgbox.setWindowModality(QtCore.Qt.ApplicationModal)\n    msgbox.show()\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_photoshop/api/lib.html#client.ayon_photoshop.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_photoshop/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n    selection = stub().get_selected_layers()\n    try:\n        yield selection\n    finally:\n        stub().select_layers(selection)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/lib.html#client.ayon_photoshop.api.lib.maintained_visibility","title":"<code>maintained_visibility(layers=None)</code>","text":"<p>Maintain visibility during context.</p> Source code in <code>client/ayon_photoshop/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_visibility(layers=None):\n    \"\"\"Maintain visibility during context.\n\n    Args:\n        layers (list) of PSItem (used for caching)\n    \"\"\"\n    visibility = {}\n    if not layers:\n        layers = stub().get_layers()\n    for layer in layers:\n        visibility[layer.id] = layer.visible\n    try:\n        yield\n    finally:\n        for layer in layers:\n            stub().set_visible(layer.id, visibility[layer.id])\n            pass\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/lib.html#client.ayon_photoshop.api.lib.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Loops through all plugins, logs to console. Used for tests. Args:     log (Logger)     close_plugin_name (Optional[str]): Name of plugin with responsibility         to close application.</p> Source code in <code>client/ayon_photoshop/api/lib.py</code> <pre><code>def publish_in_test(log, close_plugin_name=None):\n    \"\"\"Loops through all plugins, logs to console. Used for tests.\n    Args:\n        log (Logger)\n        close_plugin_name (Optional[str]): Name of plugin with responsibility\n            to close application.\n    \"\"\"\n\n    # Error exit as soon as any error occurs.\n    error_format = \"Failed {plugin.__name__}: {error} -- {error.traceback}\"\n    close_plugin = find_close_plugin(close_plugin_name, log)\n\n    for result in pyblish.util.publish_iter():\n        for record in result[\"records\"]:\n            # Why do we log again? pyblish logger is logging to stdout...\n            log.info(\"{}: {}\".format(result[\"plugin\"].label, record.msg))\n\n        if not result[\"error\"]:\n            continue\n\n        # QUESTION We don't break on error?\n        error_message = error_format.format(**result)\n        log.error(error_message)\n        if close_plugin:  # close host app explicitly after error\n            context = pyblish.api.Context()\n            try:\n                close_plugin().process(context)\n            except Exception as exp:\n                print(exp)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.PhotoshopHost","title":"<code>PhotoshopHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>class PhotoshopHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"photoshop\"\n\n    def install(self):\n        \"\"\"Install Photoshop-specific functionality needed for integration.\n\n        This function is called automatically on calling\n        `api.install(photoshop)`.\n        \"\"\"\n        log.info(\"Installing OpenPype Photoshop...\")\n        pyblish.api.register_host(\"photoshop\")\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        register_event_callback(\"application.launched\", on_application_launch)\n\n    def current_file(self):\n        try:\n            full_name = lib.stub().get_active_document_full_name()\n            if full_name and full_name != \"null\":\n                return os.path.normpath(full_name).replace(\"\\\\\", \"/\")\n        except Exception:\n            pass\n\n        return None\n\n    def work_root(self, session):\n        return os.path.normpath(session[\"AYON_WORKDIR\"]).replace(\"\\\\\", \"/\")\n\n    def open_workfile(self, filepath):\n        lib.stub().open(filepath)\n\n        return True\n\n    def save_workfile(self, filepath=None):\n        _, ext = os.path.splitext(filepath)\n        lib.stub().saveAs(filepath, ext[1:], True)\n\n    def get_current_workfile(self):\n        return self.current_file()\n\n    def workfile_has_unsaved_changes(self):\n        if self.current_file():\n            return not lib.stub().is_saved()\n\n        return False\n\n    def get_workfile_extensions(self):\n        return [\".psd\", \".psb\"]\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        \"\"\"Get stored values for context (validation enable/disable etc)\"\"\"\n        meta = _get_stub().get_layers_metadata()\n        for item in meta:\n            if item.get(\"id\") == \"publish_context\":\n                item.pop(\"id\")\n                return item\n\n        return {}\n\n    def update_context_data(self, data, changes):\n        \"\"\"Store value needed for context\"\"\"\n        item = data\n        item[\"id\"] = \"publish_context\"\n        _get_stub().imprint(item[\"id\"], item)\n\n    def list_instances(self):\n        \"\"\"List all created instances to publish from current workfile.\n\n        Pulls from File &gt; File Info\n\n        Returns:\n            (list) of dictionaries matching instances format\n        \"\"\"\n        stub = _get_stub()\n\n        if not stub:\n            return []\n\n        instances = []\n        layers_meta = stub.get_layers_metadata()\n        if layers_meta:\n            for instance in layers_meta:\n                if instance.get(\"id\") in {\n                    AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n                }:\n                    instances.append(instance)\n\n        return instances\n\n    def remove_instance(self, instance):\n        \"\"\"Remove instance from current workfile metadata.\n\n        Updates metadata of current file in File &gt; File Info and removes\n        icon highlight on group layer.\n\n        Args:\n            instance (dict): instance representation from subsetmanager model\n        \"\"\"\n        stub = _get_stub()\n\n        if not stub:\n            return\n\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n        if not inst_id:\n            log.warning(\"No instance identifier for {}\".format(instance))\n            return\n\n        stub.remove_instance(inst_id)\n\n        if instance.get(\"members\"):\n            item = stub.get_layer(instance[\"members\"][0])\n            if item:\n                stub.rename_layer(item.id,\n                                  item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.PhotoshopHost.get_context_data","title":"<code>get_context_data()</code>","text":"<p>Get stored values for context (validation enable/disable etc)</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def get_context_data(self):\n    \"\"\"Get stored values for context (validation enable/disable etc)\"\"\"\n    meta = _get_stub().get_layers_metadata()\n    for item in meta:\n        if item.get(\"id\") == \"publish_context\":\n            item.pop(\"id\")\n            return item\n\n    return {}\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.PhotoshopHost.install","title":"<code>install()</code>","text":"<p>Install Photoshop-specific functionality needed for integration.</p> <p>This function is called automatically on calling <code>api.install(photoshop)</code>.</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install Photoshop-specific functionality needed for integration.\n\n    This function is called automatically on calling\n    `api.install(photoshop)`.\n    \"\"\"\n    log.info(\"Installing OpenPype Photoshop...\")\n    pyblish.api.register_host(\"photoshop\")\n\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n\n    register_event_callback(\"application.launched\", on_application_launch)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.PhotoshopHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances to publish from current workfile.</p> <p>Pulls from File &gt; File Info</p> <p>Returns:</p> Type Description <p>(list) of dictionaries matching instances format</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances to publish from current workfile.\n\n    Pulls from File &gt; File Info\n\n    Returns:\n        (list) of dictionaries matching instances format\n    \"\"\"\n    stub = _get_stub()\n\n    if not stub:\n        return []\n\n    instances = []\n    layers_meta = stub.get_layers_metadata()\n    if layers_meta:\n        for instance in layers_meta:\n            if instance.get(\"id\") in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                instances.append(instance)\n\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.PhotoshopHost.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance from current workfile metadata.</p> <p>Updates metadata of current file in File &gt; File Info and removes icon highlight on group layer.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>dict</code> <p>instance representation from subsetmanager model</p> required Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def remove_instance(self, instance):\n    \"\"\"Remove instance from current workfile metadata.\n\n    Updates metadata of current file in File &gt; File Info and removes\n    icon highlight on group layer.\n\n    Args:\n        instance (dict): instance representation from subsetmanager model\n    \"\"\"\n    stub = _get_stub()\n\n    if not stub:\n        return\n\n    inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n    if not inst_id:\n        log.warning(\"No instance identifier for {}\".format(instance))\n        return\n\n    stub.remove_instance(inst_id)\n\n    if instance.get(\"members\"):\n        item = stub.get_layer(instance[\"members\"][0])\n        if item:\n            stub.rename_layer(item.id,\n                              item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.PhotoshopHost.update_context_data","title":"<code>update_context_data(data, changes)</code>","text":"<p>Store value needed for context</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def update_context_data(self, data, changes):\n    \"\"\"Store value needed for context\"\"\"\n    item = data\n    item[\"id\"] = \"publish_context\"\n    _get_stub().imprint(item[\"id\"], item)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.cache_and_get_instances","title":"<code>cache_and_get_instances(creator)</code>","text":"<p>Cache instances in shared data.</p> <p>Storing all instances as a list as legacy instances might be still present. Args:     creator (Creator): Plugin which would like to get instances from host. Returns:     List[]: list of all instances stored in metadata</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def cache_and_get_instances(creator):\n    \"\"\"Cache instances in shared data.\n\n    Storing all instances as a list as legacy instances might be still present.\n    Args:\n        creator (Creator): Plugin which would like to get instances from host.\n    Returns:\n        List[]: list of all instances stored in metadata\n    \"\"\"\n    shared_key = \"openpype.photoshop.instances\"\n    if shared_key not in creator.collection_shared_data:\n        creator.collection_shared_data[shared_key] = \\\n            creator.host.list_instances()\n    return creator.collection_shared_data[shared_key]\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.containerise","title":"<code>containerise(name, namespace, layer, context, loader=None, suffix='_CON')</code>","text":"<p>Imprint layer with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>layer</code> <code>PSItem</code> <p>Layer to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'_CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def containerise(\n    name, namespace, layer, context, loader=None, suffix=\"_CON\"\n):\n    \"\"\"Imprint layer with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        layer (PSItem): Layer to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n    \"\"\"\n    layer.name = name + suffix\n\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"members\": [str(layer.id)]\n    }\n    stub = lib.stub()\n    stub.imprint(layer.id, data)\n\n    return layer\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/pipeline.html#client.ayon_photoshop.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active Photoshop document</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Photoshop; once loaded they are called 'containers'</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_photoshop/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active Photoshop document\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Photoshop; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    try:\n        stub = lib.stub()  # only after Photoshop is up\n    except lib.ConnectionNotEstablishedYet:\n        print(\"Not connected yet, ignoring\")\n        return\n\n    if not stub.get_active_document_name():\n        return\n\n    layers_meta = stub.get_layers_metadata()  # minimalize calls to PS\n    for layer in stub.get_layers():\n        data = stub.read(layer, layers_meta)\n\n        # Skip non-tagged layers.\n        if not data:\n            continue\n\n        # Filter to only containers.\n        if \"container\" not in data[\"id\"]:\n            continue\n\n        # Append transient data\n        data[\"objectName\"] = layer.name.replace(stub.LOADED_ICON, '')\n        data[\"layer\"] = layer\n\n        yield data\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_photoshop/api/plugin.html#client.ayon_photoshop.api.plugin.get_unique_layer_name","title":"<code>get_unique_layer_name(layers, container_name, product_name)</code>","text":"<p>Prepare unique layer name.</p> <p>Gets all layer names and if '_' is present, it adds suffix '1', or increases the suffix by 1. <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> required <code>product_name</code> <code>str</code> required <p>Returns:</p> Name Type Description <code>str</code> <p>name_00X (without version)</p> Source code in <code>client/ayon_photoshop/api/plugin.py</code> <pre><code>def get_unique_layer_name(layers, container_name, product_name):\n    \"\"\"Prepare unique layer name.\n\n    Gets all layer names and if '&lt;container_name&gt;_&lt;product_name&gt;' is present,\n    it adds suffix '1', or increases the suffix by 1.\n\n    Args:\n        layers (list) of dict with layers info (name, id etc.)\n        container_name (str):\n        product_name (str):\n\n    Returns:\n        str: name_00X (without version)\n    \"\"\"\n    name = \"{}_{}\".format(container_name, product_name)\n    names = {}\n    for layer in layers:\n        layer_name = re.sub(r'_\\d{3}$', '', layer.name)\n        if layer_name in names.keys():\n            names[layer_name] = names[layer_name] + 1\n        else:\n            names[layer_name] = 1\n    occurrences = names.get(name, 0)\n\n    return \"{}_{:0&gt;3d}\".format(name, occurrences + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html","title":"webserver","text":"<p>Webserver for communication with photoshop.</p> <p>Aiohttp (Asyncio) based websocket server used for communication with host application.</p> <p>This webserver is started in spawned Python process that opens DCC during its launch, waits for connection from DCC and handles communication going forward. Server is closed before Python process is killed.</p>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html#client.ayon_photoshop.api.webserver.WebServerThread","title":"<code>WebServerThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Listener for websocket rpc requests.</p> <p>It would be probably better to \"attach\" this to main thread (as for example Harmony needs to run something on main thread), but currently it creates separate thread and separate asyncio event loop</p> Source code in <code>client/ayon_photoshop/api/webserver.py</code> <pre><code>class WebServerThread(threading.Thread):\n    \"\"\" Listener for websocket rpc requests.\n\n        It would be probably better to \"attach\" this to main thread (as for\n        example Harmony needs to run something on main thread), but currently\n        it creates separate thread and separate asyncio event loop\n    \"\"\"\n    def __init__(self, module, port):\n        super(WebServerThread, self).__init__()\n\n        self.is_running = False\n        self.port = port\n        self.module = module\n        self.loop = None\n        self.runner = None\n        self.site = None\n        self.tasks = []\n\n    def run(self):\n        self.is_running = True\n\n        try:\n            log.info(\"Starting web server\")\n            self.loop = asyncio.new_event_loop()  # create new loop for thread\n            asyncio.set_event_loop(self.loop)\n\n            self.loop.run_until_complete(self.start_server())\n\n            websocket_url = \"ws://localhost:{}/ws\".format(self.port)\n\n            log.debug(\n                \"Running Websocket server on URL: \\\"{}\\\"\".format(websocket_url)\n            )\n\n            asyncio.ensure_future(self.check_shutdown(), loop=self.loop)\n            self.loop.run_forever()\n        except Exception:\n            self.is_running = False\n            log.warning(\n                \"Websocket Server service has failed\", exc_info=True\n            )\n            raise\n        finally:\n            self.loop.close()  # optional\n\n            self.is_running = False\n            self.module.thread_stopped()\n            log.info(\"Websocket server stopped\")\n\n    async def start_server(self):\n        \"\"\" Starts runner and TCPsite \"\"\"\n        self.runner = web.AppRunner(self.module.app)\n        await self.runner.setup()\n        self.site = web.TCPSite(self.runner, 'localhost', self.port)\n        await self.site.start()\n\n    def stop(self):\n        \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n        self.is_running = False\n\n    async def check_shutdown(self):\n        \"\"\" Future that is running and checks if server should be running\n            periodically.\n        \"\"\"\n        while self.is_running:\n            while self.tasks:\n                task = self.tasks.pop(0)\n                log.debug(\"waiting for task {}\".format(task))\n                await task\n                log.debug(\"returned value {}\".format(task.result))\n\n            await asyncio.sleep(0.5)\n\n        log.debug(\"Starting shutdown\")\n        await self.site.stop()\n        log.debug(\"Site stopped\")\n        await self.runner.cleanup()\n        log.debug(\"Runner stopped\")\n        tasks = [task for task in asyncio.all_tasks() if\n                 task is not asyncio.current_task()]\n        list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        log.debug(f'Finished awaiting cancelled tasks, results: {results}...')\n        await self.loop.shutdown_asyncgens()\n        # to really make sure everything else has time to stop\n        await asyncio.sleep(0.07)\n        self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html#client.ayon_photoshop.api.webserver.WebServerThread.check_shutdown","title":"<code>check_shutdown()</code>  <code>async</code>","text":"<p>Future that is running and checks if server should be running periodically.</p> Source code in <code>client/ayon_photoshop/api/webserver.py</code> <pre><code>async def check_shutdown(self):\n    \"\"\" Future that is running and checks if server should be running\n        periodically.\n    \"\"\"\n    while self.is_running:\n        while self.tasks:\n            task = self.tasks.pop(0)\n            log.debug(\"waiting for task {}\".format(task))\n            await task\n            log.debug(\"returned value {}\".format(task.result))\n\n        await asyncio.sleep(0.5)\n\n    log.debug(\"Starting shutdown\")\n    await self.site.stop()\n    log.debug(\"Site stopped\")\n    await self.runner.cleanup()\n    log.debug(\"Runner stopped\")\n    tasks = [task for task in asyncio.all_tasks() if\n             task is not asyncio.current_task()]\n    list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    log.debug(f'Finished awaiting cancelled tasks, results: {results}...')\n    await self.loop.shutdown_asyncgens()\n    # to really make sure everything else has time to stop\n    await asyncio.sleep(0.07)\n    self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html#client.ayon_photoshop.api.webserver.WebServerThread.start_server","title":"<code>start_server()</code>  <code>async</code>","text":"<p>Starts runner and TCPsite</p> Source code in <code>client/ayon_photoshop/api/webserver.py</code> <pre><code>async def start_server(self):\n    \"\"\" Starts runner and TCPsite \"\"\"\n    self.runner = web.AppRunner(self.module.app)\n    await self.runner.setup()\n    self.site = web.TCPSite(self.runner, 'localhost', self.port)\n    await self.site.start()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html#client.ayon_photoshop.api.webserver.WebServerThread.stop","title":"<code>stop()</code>","text":"<p>Sets is_running flag to false, 'check_shutdown' shuts server down</p> Source code in <code>client/ayon_photoshop/api/webserver.py</code> <pre><code>def stop(self):\n    \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n    self.is_running = False\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html#client.ayon_photoshop.api.webserver.WebServerTool","title":"<code>WebServerTool</code>","text":"<p>Basic POC implementation of asychronic websocket RPC server. Uses class in external_app_1.py to mimic implementation for single external application. 'test_client' folder contains two test implementations of client</p> Source code in <code>client/ayon_photoshop/api/webserver.py</code> <pre><code>class WebServerTool:\n    \"\"\"\n        Basic POC implementation of asychronic websocket RPC server.\n        Uses class in external_app_1.py to mimic implementation for single\n        external application.\n        'test_client' folder contains two test implementations of client\n    \"\"\"\n    _instance = None\n\n    def __init__(self):\n        WebServerTool._instance = self\n\n        self.client = None\n        self.handlers = {}\n        self.on_stop_callbacks = []\n\n        port = None\n        host_name = \"localhost\"\n        websocket_url = os.getenv(\"WEBSOCKET_URL\")\n        if websocket_url:\n            parsed = urllib.parse.urlparse(websocket_url)\n            port = parsed.port\n            host_name = parsed.netloc.split(\":\")[0]\n        if not port:\n            port = 8098  # fallback\n\n        self.port = port\n        self.host_name = host_name\n\n        self.app = web.Application()\n\n        # add route with multiple methods for single \"external app\"\n        self.webserver_thread = WebServerThread(self, self.port)\n\n    def add_route(self, *args, **kwargs):\n        self.app.router.add_route(*args, **kwargs)\n\n    def add_static(self, *args, **kwargs):\n        self.app.router.add_static(*args, **kwargs)\n\n    def start_server(self):\n        if self.webserver_thread and not self.webserver_thread.is_alive():\n            self.webserver_thread.start()\n\n    def stop_server(self):\n        self.stop()\n\n    async def send_context_change(self, host):\n        \"\"\"\n            Calls running webserver to inform about context change\n\n            Used when new PS/AE should be triggered,\n            but one already running, without\n            this publish would point to old context.\n        \"\"\"\n        client = WSRPCClient(os.getenv(\"WEBSOCKET_URL\"),\n                             loop=asyncio.get_event_loop())\n        await client.connect()\n\n        context = get_global_context()\n        project_name = context[\"project_name\"]\n        folder_path = context[\"folder_path\"]\n        task_name = context[\"task_name\"]\n        log.info(\"Sending context change to {}{}/{}\".format(\n            project_name, folder_path, task_name\n        ))\n\n        await client.call(\n            '{}.set_context'.format(host),\n            project=project_name,\n            folder=folder_path,\n            task=task_name\n        )\n        await client.close()\n\n    def port_occupied(self, host_name, port):\n        \"\"\"\n            Check if 'url' is already occupied.\n\n            This could mean, that app is already running and we are trying open it\n            again. In that case, use existing running webserver.\n            Check here is easier than capturing exception from thread.\n        \"\"\"\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as con:\n            result = con.connect_ex((host_name, port)) == 0\n\n        if result:\n            print(f\"Port {port} is already in use\")\n        return result\n\n    def call(self, func):\n        log.debug(\"websocket.call {}\".format(func))\n        future = asyncio.run_coroutine_threadsafe(\n            func,\n            self.webserver_thread.loop\n        )\n        result = future.result()\n        return result\n\n    @staticmethod\n    def get_instance():\n        if WebServerTool._instance is None:\n            WebServerTool()\n        return WebServerTool._instance\n\n    @property\n    def is_running(self):\n        if not self.webserver_thread:\n            return False\n        return self.webserver_thread.is_running\n\n    def stop(self):\n        if not self.is_running:\n            return\n        try:\n            log.debug(\"Stopping websocket server\")\n            self.webserver_thread.is_running = False\n            self.webserver_thread.stop()\n        except Exception:\n            log.warning(\n                \"Error has happened during Killing websocket server\",\n                exc_info=True\n            )\n\n    def thread_stopped(self):\n        for callback in self.on_stop_callbacks:\n            callback()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html#client.ayon_photoshop.api.webserver.WebServerTool.port_occupied","title":"<code>port_occupied(host_name, port)</code>","text":"<p>Check if 'url' is already occupied.</p> <p>This could mean, that app is already running and we are trying open it again. In that case, use existing running webserver. Check here is easier than capturing exception from thread.</p> Source code in <code>client/ayon_photoshop/api/webserver.py</code> <pre><code>def port_occupied(self, host_name, port):\n    \"\"\"\n        Check if 'url' is already occupied.\n\n        This could mean, that app is already running and we are trying open it\n        again. In that case, use existing running webserver.\n        Check here is easier than capturing exception from thread.\n    \"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as con:\n        result = con.connect_ex((host_name, port)) == 0\n\n    if result:\n        print(f\"Port {port} is already in use\")\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/webserver.html#client.ayon_photoshop.api.webserver.WebServerTool.send_context_change","title":"<code>send_context_change(host)</code>  <code>async</code>","text":"<p>Calls running webserver to inform about context change</p> <p>Used when new PS/AE should be triggered, but one already running, without this publish would point to old context.</p> Source code in <code>client/ayon_photoshop/api/webserver.py</code> <pre><code>async def send_context_change(self, host):\n    \"\"\"\n        Calls running webserver to inform about context change\n\n        Used when new PS/AE should be triggered,\n        but one already running, without\n        this publish would point to old context.\n    \"\"\"\n    client = WSRPCClient(os.getenv(\"WEBSOCKET_URL\"),\n                         loop=asyncio.get_event_loop())\n    await client.connect()\n\n    context = get_global_context()\n    project_name = context[\"project_name\"]\n    folder_path = context[\"folder_path\"]\n    task_name = context[\"task_name\"]\n    log.info(\"Sending context change to {}{}/{}\".format(\n        project_name, folder_path, task_name\n    ))\n\n    await client.call(\n        '{}.set_context'.format(host),\n        project=project_name,\n        folder=folder_path,\n        task=task_name\n    )\n    await client.close()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html","title":"ws_stub","text":"<p>Stub handling connection from server to client. Used anywhere solution is calling client methods.</p>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PSItem","title":"<code>PSItem</code>","text":"<p>               Bases: <code>object</code></p> <p>Object denoting layer or group item in PS. Each item is created in PS by any Loader, but contains same fields, which are being used in later processing.</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>@attr.s\nclass PSItem(object):\n    \"\"\"\n        Object denoting layer or group item in PS. Each item is created in\n        PS by any Loader, but contains same fields, which are being used\n        in later processing.\n    \"\"\"\n    # metadata\n    id = attr.ib()  # id created by AE, could be used for querying\n    name = attr.ib()  # name of item\n    group = attr.ib(default=None)  # item type (footage, folder, comp)\n    parents = attr.ib(factory=list)\n    visible = attr.ib(default=True)\n    type = attr.ib(default=None)\n    # all imported elements, single for\n    members = attr.ib(factory=list)\n    long_name = attr.ib(default=None)\n    color_code = attr.ib(default=None)  # color code of layer\n    instance_id = attr.ib(default=None)\n\n    @property\n    def clean_name(self):\n        \"\"\"Returns layer name without publish icon highlight\n\n        Returns:\n            (str)\n        \"\"\"\n        return (self.name.replace(PhotoshopServerStub.PUBLISH_ICON, '')\n                         .replace(PhotoshopServerStub.LOADED_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PSItem.clean_name","title":"<code>clean_name</code>  <code>property</code>","text":"<p>Returns layer name without publish icon highlight</p> <p>Returns:</p> Type Description <p>(str)</p>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub","title":"<code>PhotoshopServerStub</code>","text":"<p>Stub for calling function on client (Photoshop js) side. Expects that client is already connected (started when avalon menu is opened). 'self.websocketserver.call' is used as async wrapper</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>class PhotoshopServerStub:\n    \"\"\"\n        Stub for calling function on client (Photoshop js) side.\n        Expects that client is already connected (started when avalon menu\n        is opened).\n        'self.websocketserver.call' is used as async wrapper\n    \"\"\"\n    PUBLISH_ICON = '\\u2117 '\n    LOADED_ICON = '\\u25bc'\n\n    def __init__(self):\n        self.websocketserver = WebServerTool.get_instance()\n        self.client = self.get_client()\n\n    @staticmethod\n    def get_client():\n        \"\"\"\n            Return first connected client to WebSocket\n            TODO implement selection by Route\n        :return: &lt;WebSocketAsync&gt; client\n        \"\"\"\n        clients = WebSocketAsync.get_clients()\n        client = None\n        if len(clients) &gt; 0:\n            key = list(clients.keys())[0]\n            client = clients.get(key)\n\n        return client\n\n    def open(self, path):\n        \"\"\"Open file located at 'path' (local).\n\n        Args:\n            path(string): file path locally\n        Returns: None\n        \"\"\"\n        self.websocketserver.call(\n            self.client.call('Photoshop.open', path=path)\n        )\n\n    def read(self, layer, layers_meta=None):\n        \"\"\"Parses layer metadata from Headline field of active document.\n\n        Args:\n            layer: (PSItem)\n            layers_meta: full list from Headline (for performance in loops)\n        Returns:\n            (dict) of layer metadata stored in PS file\n\n        Example:\n            {\n                'id': 'pyblish.avalon.container',\n                'loader': 'ImageLoader',\n                'members': ['64'],\n                'name': 'imageMainMiddle',\n                'namespace': 'Hero_imageMainMiddle_001',\n                'representation': '6203dc91e80934d9f6ee7d96',\n                'schema': 'openpype:container-2.0'\n            }\n        \"\"\"\n        if layers_meta is None:\n            layers_meta = self.get_layers_metadata()\n\n        for layer_meta in layers_meta:\n            layer_id = layer_meta.get(\"uuid\")  # legacy\n            if layer_meta.get(\"members\"):\n                layer_id = layer_meta[\"members\"][0]\n            if str(layer.id) == str(layer_id):\n                return layer_meta\n        print(\"Unable to find layer metadata for {}\".format(layer.id))\n\n    def imprint(self, item_id, data, all_layers=None, items_meta=None):\n        \"\"\"Save layer metadata to Headline field of active document\n\n        Stores metadata in format:\n        [{\n            \"active\":true,\n            \"productName\":\"imageBG\",\n            \"productType\":\"image\",\n            \"id\":\"ayon.create.instance\",\n            \"folderPath\":\"Town\",\n            \"uuid\": \"8\"\n        }] - for created instances\n        OR\n        [{\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": \"ayon.create.instance\",\n            \"name\": \"imageMG\",\n            \"namespace\": \"Jungle_imageMG_001\",\n            \"loader\": \"ImageLoader\",\n            \"representation\": \"5fbfc0ee30a946093c6ff18a\",\n            \"members\": [\n                \"40\"\n            ]\n        }] - for loaded instances\n\n        Args:\n            item_id (str):\n            data(string): json representation for single layer\n            all_layers (list of PSItem): for performance, could be\n                injected for usage in loop, if not, single call will be\n                triggered\n            items_meta(string): json representation from Headline\n                           (for performance - provide only if imprint is in\n                           loop - value should be same)\n        Returns: None\n        \"\"\"\n        if not items_meta:\n            items_meta = self.get_layers_metadata()\n\n        # json.dumps writes integer values in a dictionary to string, so\n        # anticipating it here.\n        item_id = str(item_id)\n        is_new = True\n        result_meta = []\n        for item_meta in items_meta:\n            if ((item_meta.get('members') and\n                 item_id == str(item_meta.get('members')[0])) or\n                    item_meta.get(\"instance_id\") == item_id):\n                is_new = False\n                if data:\n                    item_meta.update(data)\n                    result_meta.append(item_meta)\n            else:\n                result_meta.append(item_meta)\n\n        if is_new:\n            result_meta.append(data)\n\n        # Ensure only valid ids are stored.\n        if not all_layers:\n            all_layers = self.get_layers()\n        layer_ids = [layer.id for layer in all_layers]\n        cleaned_data = []\n\n        for item in result_meta:\n            if item.get(\"members\"):\n                if int(item[\"members\"][0]) not in layer_ids:\n                    continue\n\n            cleaned_data.append(item)\n\n        payload = json.dumps(cleaned_data, indent=4)\n        self.websocketserver.call(\n            self.client.call('Photoshop.imprint', payload=payload)\n        )\n\n    def get_layers(self):\n        \"\"\"Returns JSON document with all(?) layers in active document.\n\n        Returns: &lt;list of PSItem&gt;\n                    Format of tuple: { 'id':'123',\n                                     'name': 'My Layer 1',\n                                     'type': 'GUIDE'|'FG'|'BG'|'OBJ'\n                                     'visible': 'true'|'false'\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call('Photoshop.get_layers')\n        )\n\n        return self._to_records(res)\n\n    def get_layer(self, layer_id):\n        \"\"\"\n            Returns PSItem for specific 'layer_id' or None if not found\n        Args:\n            layer_id (string): unique layer id, stored in 'uuid' field\n\n        Returns:\n            (PSItem) or None\n        \"\"\"\n        layers = self.get_layers()\n        for layer in layers:\n            if str(layer.id) == str(layer_id):\n                return layer\n\n    def get_layers_in_layers(self, layers):\n        \"\"\"Return all layers that belong to layers (might be groups).\n\n        Args:\n            layers &lt;list of PSItem&gt;:\n\n        Returns:\n            &lt;list of PSItem&gt;\n        \"\"\"\n        parent_ids = set([lay.id for lay in layers])\n\n        return self._get_layers_in_layers(parent_ids)\n\n    def get_layers_in_layers_ids(self, layers_ids, layers=None):\n        \"\"\"Return all layers that belong to layers (might be groups).\n\n        Args:\n            layers_ids &lt;list of Int&gt;\n            layers &lt;list of PSItem&gt;:\n\n        Returns:\n            &lt;list of PSItem&gt;\n        \"\"\"\n        parent_ids = set(layers_ids)\n\n        return self._get_layers_in_layers(parent_ids, layers)\n\n    def _get_layers_in_layers(self, parent_ids, layers=None):\n        if not layers:\n            layers = self.get_layers()\n\n        all_layers = layers\n        ret = []\n\n        for layer in all_layers:\n            parents = set(layer.parents)\n            if len(parent_ids &amp; parents) &gt; 0:\n                ret.append(layer)\n            if layer.id in parent_ids:\n                ret.append(layer)\n\n        return ret\n\n    def create_group(self, name):\n        \"\"\"Create new group (eg. LayerSet)\n\n        Returns:\n            &lt;PSItem&gt;\n        \"\"\"\n        enhanced_name = self.PUBLISH_ICON + name\n        ret = self.websocketserver.call(\n            self.client.call('Photoshop.create_group', name=enhanced_name)\n        )\n        # create group on PS is asynchronous, returns only id\n        return PSItem(id=ret, name=name, group=True)\n\n    def group_selected_layers(self, name):\n        \"\"\"Group selected layers into new LayerSet (eg. group)\n\n        Returns:\n            (Layer)\n        \"\"\"\n        enhanced_name = self.PUBLISH_ICON + name\n        res = self.websocketserver.call(\n            self.client.call(\n                'Photoshop.group_selected_layers', name=enhanced_name\n            )\n        )\n        res = self._to_records(res)\n        if res:\n            rec = res.pop()\n            rec.name = rec.name.replace(self.PUBLISH_ICON, '')\n            return rec\n        raise ValueError(\"No group record returned\")\n\n    def get_selected_layers(self):\n        \"\"\"Get a list of actually selected layers.\n\n        Returns: &lt;list of Layer('id':XX, 'name':\"YYY\")&gt;\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call('Photoshop.get_selected_layers')\n        )\n        return self._to_records(res)\n\n    def select_layers(self, layers):\n        \"\"\"Selects specified layers in Photoshop by its ids.\n\n        Args:\n            layers: &lt;list of Layer('id':XX, 'name':\"YYY\")&gt;\n        \"\"\"\n        layers_id = [str(lay.id) for lay in layers]\n        self.websocketserver.call(\n            self.client.call(\n                'Photoshop.select_layers',\n                layers=json.dumps(layers_id)\n            )\n        )\n\n    def get_active_document_full_name(self):\n        \"\"\"Returns full name with path of active document via ws call\n\n        Returns(string):\n            full path with name\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call('Photoshop.get_active_document_full_name')\n        )\n\n        return res\n\n    def get_active_document_name(self):\n        \"\"\"Returns just a name of active document via ws call\n\n        Returns(string):\n            file name\n        \"\"\"\n        return self.websocketserver.call(\n            self.client.call('Photoshop.get_active_document_name')\n        )\n\n    def is_saved(self):\n        \"\"\"Returns true if no changes in active document\n\n        Returns:\n            &lt;boolean&gt;\n        \"\"\"\n        return self.websocketserver.call(\n            self.client.call('Photoshop.is_saved')\n        )\n\n    def save(self):\n        \"\"\"Saves active document\"\"\"\n        self.websocketserver.call(\n            self.client.call('Photoshop.save')\n        )\n\n    def saveAs(self, image_path, ext, as_copy):\n        \"\"\"Saves active document to psd (copy) or png or jpg\n\n        Args:\n            image_path(string): full local path\n            ext: &lt;string psd|jpg|png&gt;\n            as_copy: &lt;boolean&gt;\n        Returns: None\n        \"\"\"\n        self.websocketserver.call(\n            self.client.call(\n                'Photoshop.saveAs',\n                image_path=image_path,\n                ext=ext,\n                as_copy=as_copy\n            )\n        )\n\n    def set_visible(self, layer_id, visibility):\n        \"\"\"Set layer with 'layer_id' to 'visibility'\n\n        Args:\n            layer_id: &lt;int&gt;\n            visibility: &lt;true - set visible, false - hide&gt;\n        Returns: None\n        \"\"\"\n        self.websocketserver.call(\n            self.client.call(\n                'Photoshop.set_visible',\n                layer_id=layer_id,\n                visibility=visibility\n            )\n        )\n\n    def hide_all_others_layers(self, layers):\n        \"\"\"hides all layers that are not part of the list or that are not\n        children of this list\n\n        Args:\n            layers (list): list of PSItem - highest hierarchy\n        \"\"\"\n        extract_ids = set([ll.id for ll in self.get_layers_in_layers(layers)])\n\n        self.hide_all_others_layers_ids(extract_ids)\n\n    def hide_all_others_layers_ids(self, extract_ids, layers=None):\n        \"\"\"hides all layers that are not part of the list or that are not\n        children of this list\n\n        Args:\n            extract_ids (list): list of integer that should be visible\n            layers (list) of PSItem (used for caching)\n        \"\"\"\n        if not layers:\n            layers = self.get_layers()\n        for layer in layers:\n            if layer.visible and layer.id not in extract_ids:\n                self.set_visible(layer.id, False)\n\n    def get_layers_metadata(self):\n        \"\"\"Reads layers metadata from Headline from active document in PS.\n        (Headline accessible by File &gt; File Info)\n\n        Returns:\n            (list)\n            example:\n                {\"8\":{\"active\":true,\"productName\":\"imageBG\",\n                      \"productType\":\"image\",\"id\":\"ayon.create.instance\",\n                      \"folderPath\":\"/Town\"}}\n                8 is layer(group) id - used for deletion, update etc.\n        \"\"\"\n        res = self.websocketserver.call(self.client.call('Photoshop.read'))\n        layers_data = []\n        try:\n            if res:\n                layers_data = json.loads(res)\n        except json.decoder.JSONDecodeError:\n            raise ValueError(\"{} cannot be parsed, recreate meta\".format(res))\n        # format of metadata changed from {} to [] because of standardization\n        # keep current implementation logic as its working\n        if isinstance(layers_data, dict):\n            for layer_id, layer_meta in layers_data.items():\n                if layer_meta.get(\"schema\") != \"openpype:container-2.0\":\n                    layer_meta[\"members\"] = [str(layer_id)]\n            layers_data = list(layers_data.values())\n        return layers_data\n\n    def import_smart_object(self, path, layer_name, as_reference=False):\n        \"\"\"Import the file at `path` as a smart object to active document.\n\n        Args:\n            path (str): File path to import.\n            layer_name (str): Unique layer name to differentiate how many times\n                same smart object was loaded\n            as_reference (bool): pull in content or reference\n        \"\"\"\n        enhanced_name = self.LOADED_ICON + layer_name\n        res = self.websocketserver.call(\n            self.client.call(\n                'Photoshop.import_smart_object',\n                path=path,\n                name=enhanced_name,\n                as_reference=as_reference\n            )\n        )\n        rec = self._to_records(res).pop()\n        if rec:\n            rec.name = rec.name.replace(self.LOADED_ICON, '')\n        return rec\n\n    def replace_smart_object(self, layer, path, layer_name):\n        \"\"\"Replace the smart object `layer` with file at `path`\n\n        Args:\n            layer (PSItem):\n            path (str): File to import.\n            layer_name (str): Unique layer name to differentiate how many times\n                same smart object was loaded\n        \"\"\"\n        enhanced_name = self.LOADED_ICON + layer_name\n        self.websocketserver.call(\n            self.client.call(\n                'Photoshop.replace_smart_object',\n                layer_id=layer.id,\n                path=path,\n                name=enhanced_name\n            )\n        )\n\n    def delete_layer(self, layer_id):\n        \"\"\"Deletes specific layer by it's id.\n\n        Args:\n            layer_id (int): id of layer to delete\n        \"\"\"\n        self.websocketserver.call(\n            self.client.call('Photoshop.delete_layer', layer_id=layer_id)\n        )\n\n    def rename_layer(self, layer_id, name):\n        \"\"\"Renames specific layer by it's id.\n\n        Args:\n            layer_id (int): id of layer to delete\n            name (str): new name\n        \"\"\"\n        self.websocketserver.call(\n            self.client.call(\n                'Photoshop.rename_layer',\n                layer_id=layer_id,\n                name=name\n            )\n        )\n\n    def remove_instance(self, instance_id):\n        cleaned_data = []\n\n        for item in self.get_layers_metadata():\n            inst_id = item.get(\"instance_id\") or item.get(\"uuid\")\n            if inst_id != instance_id:\n                cleaned_data.append(item)\n\n        payload = json.dumps(cleaned_data, indent=4)\n\n        self.websocketserver.call(\n            self.client.call('Photoshop.imprint', payload=payload)\n        )\n\n    def get_extension_version(self):\n        \"\"\"Returns version number of installed extension.\"\"\"\n        return self.websocketserver.call(\n            self.client.call('Photoshop.get_extension_version')\n        )\n\n    def close(self):\n        \"\"\"Shutting down PS and process too.\n\n            For webpublishing only.\n        \"\"\"\n        # TODO change client.call to method with checks for client\n        self.websocketserver.call(self.client.call('Photoshop.close'))\n\n    def _to_records(self, res):\n        \"\"\"Converts string json representation into list of PSItem for\n        dot notation access to work.\n\n        Args:\n            res (string): valid json\n\n        Returns:\n            &lt;list of PSItem&gt;\n        \"\"\"\n        try:\n            layers_data = json.loads(res)\n        except json.decoder.JSONDecodeError:\n            raise ValueError(\"Received broken JSON {}\".format(res))\n        ret = []\n\n        # convert to AEItem to use dot donation\n        if isinstance(layers_data, dict):\n            layers_data = [layers_data]\n        for d in layers_data:\n            # currently implemented and expected fields\n            ret.append(PSItem(\n                d.get('id'),\n                d.get('name'),\n                d.get('group'),\n                d.get('parents'),\n                d.get('visible'),\n                d.get('type'),\n                d.get('members'),\n                d.get('long_name'),\n                d.get(\"color_code\"),\n                d.get(\"instance_id\")\n            ))\n        return ret\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.close","title":"<code>close()</code>","text":"<p>Shutting down PS and process too.</p> <p>For webpublishing only.</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def close(self):\n    \"\"\"Shutting down PS and process too.\n\n        For webpublishing only.\n    \"\"\"\n    # TODO change client.call to method with checks for client\n    self.websocketserver.call(self.client.call('Photoshop.close'))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.create_group","title":"<code>create_group(name)</code>","text":"<p>Create new group (eg. LayerSet)</p> <p>Returns:</p> Type Description <p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def create_group(self, name):\n    \"\"\"Create new group (eg. LayerSet)\n\n    Returns:\n        &lt;PSItem&gt;\n    \"\"\"\n    enhanced_name = self.PUBLISH_ICON + name\n    ret = self.websocketserver.call(\n        self.client.call('Photoshop.create_group', name=enhanced_name)\n    )\n    # create group on PS is asynchronous, returns only id\n    return PSItem(id=ret, name=name, group=True)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.delete_layer","title":"<code>delete_layer(layer_id)</code>","text":"<p>Deletes specific layer by it's id.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>id of layer to delete</p> required Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def delete_layer(self, layer_id):\n    \"\"\"Deletes specific layer by it's id.\n\n    Args:\n        layer_id (int): id of layer to delete\n    \"\"\"\n    self.websocketserver.call(\n        self.client.call('Photoshop.delete_layer', layer_id=layer_id)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_active_document_full_name","title":"<code>get_active_document_full_name()</code>","text":"<p>Returns full name with path of active document via ws call</p> <p>Returns(string):     full path with name</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_active_document_full_name(self):\n    \"\"\"Returns full name with path of active document via ws call\n\n    Returns(string):\n        full path with name\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call('Photoshop.get_active_document_full_name')\n    )\n\n    return res\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_active_document_name","title":"<code>get_active_document_name()</code>","text":"<p>Returns just a name of active document via ws call</p> <p>Returns(string):     file name</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_active_document_name(self):\n    \"\"\"Returns just a name of active document via ws call\n\n    Returns(string):\n        file name\n    \"\"\"\n    return self.websocketserver.call(\n        self.client.call('Photoshop.get_active_document_name')\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_client","title":"<code>get_client()</code>  <code>staticmethod</code>","text":"<pre><code>Return first connected client to WebSocket\nTODO implement selection by Route\n</code></pre> <p>:return:  client Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>@staticmethod\ndef get_client():\n    \"\"\"\n        Return first connected client to WebSocket\n        TODO implement selection by Route\n    :return: &lt;WebSocketAsync&gt; client\n    \"\"\"\n    clients = WebSocketAsync.get_clients()\n    client = None\n    if len(clients) &gt; 0:\n        key = list(clients.keys())[0]\n        client = clients.get(key)\n\n    return client\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_extension_version","title":"<code>get_extension_version()</code>","text":"<p>Returns version number of installed extension.</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_extension_version(self):\n    \"\"\"Returns version number of installed extension.\"\"\"\n    return self.websocketserver.call(\n        self.client.call('Photoshop.get_extension_version')\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_layer","title":"<code>get_layer(layer_id)</code>","text":"<pre><code>Returns PSItem for specific 'layer_id' or None if not found\n</code></pre> <p>Args:     layer_id (string): unique layer id, stored in 'uuid' field</p> <p>Returns:</p> Type Description <p>(PSItem) or None</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_layer(self, layer_id):\n    \"\"\"\n        Returns PSItem for specific 'layer_id' or None if not found\n    Args:\n        layer_id (string): unique layer id, stored in 'uuid' field\n\n    Returns:\n        (PSItem) or None\n    \"\"\"\n    layers = self.get_layers()\n    for layer in layers:\n        if str(layer.id) == str(layer_id):\n            return layer\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_layers","title":"<code>get_layers()</code>","text":"<p>Returns JSON document with all(?) layers in active document.</p> <p>&lt;list of PSItem&gt;</p> Type Description <p>Format of tuple: { 'id':'123',      'name': 'My Layer 1',      'type': 'GUIDE'|'FG'|'BG'|'OBJ'      'visible': 'true'|'false'</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_layers(self):\n    \"\"\"Returns JSON document with all(?) layers in active document.\n\n    Returns: &lt;list of PSItem&gt;\n                Format of tuple: { 'id':'123',\n                                 'name': 'My Layer 1',\n                                 'type': 'GUIDE'|'FG'|'BG'|'OBJ'\n                                 'visible': 'true'|'false'\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call('Photoshop.get_layers')\n    )\n\n    return self._to_records(res)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_layers_in_layers","title":"<code>get_layers_in_layers(layers)</code>","text":"<p>Return all layers that belong to layers (might be groups).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>&lt;list of PSItem&gt;</code> required <p>Returns:</p> Type Description <p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_layers_in_layers(self, layers):\n    \"\"\"Return all layers that belong to layers (might be groups).\n\n    Args:\n        layers &lt;list of PSItem&gt;:\n\n    Returns:\n        &lt;list of PSItem&gt;\n    \"\"\"\n    parent_ids = set([lay.id for lay in layers])\n\n    return self._get_layers_in_layers(parent_ids)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_layers_in_layers_ids","title":"<code>get_layers_in_layers_ids(layers_ids, layers=None)</code>","text":"<p>Return all layers that belong to layers (might be groups).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>&lt;list of PSItem&gt;</code> <code>None</code> <p>Returns:</p> Type Description <p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_layers_in_layers_ids(self, layers_ids, layers=None):\n    \"\"\"Return all layers that belong to layers (might be groups).\n\n    Args:\n        layers_ids &lt;list of Int&gt;\n        layers &lt;list of PSItem&gt;:\n\n    Returns:\n        &lt;list of PSItem&gt;\n    \"\"\"\n    parent_ids = set(layers_ids)\n\n    return self._get_layers_in_layers(parent_ids, layers)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_layers_metadata","title":"<code>get_layers_metadata()</code>","text":"<p>Reads layers metadata from Headline from active document in PS. (Headline accessible by File &gt; File Info)</p> <p>Returns:</p> Name Type Description <p>(list)</p> <code>example</code> <p>{\"8\":{\"active\":true,\"productName\":\"imageBG\",       \"productType\":\"image\",\"id\":\"ayon.create.instance\",       \"folderPath\":\"/Town\"}} 8 is layer(group) id - used for deletion, update etc.</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_layers_metadata(self):\n    \"\"\"Reads layers metadata from Headline from active document in PS.\n    (Headline accessible by File &gt; File Info)\n\n    Returns:\n        (list)\n        example:\n            {\"8\":{\"active\":true,\"productName\":\"imageBG\",\n                  \"productType\":\"image\",\"id\":\"ayon.create.instance\",\n                  \"folderPath\":\"/Town\"}}\n            8 is layer(group) id - used for deletion, update etc.\n    \"\"\"\n    res = self.websocketserver.call(self.client.call('Photoshop.read'))\n    layers_data = []\n    try:\n        if res:\n            layers_data = json.loads(res)\n    except json.decoder.JSONDecodeError:\n        raise ValueError(\"{} cannot be parsed, recreate meta\".format(res))\n    # format of metadata changed from {} to [] because of standardization\n    # keep current implementation logic as its working\n    if isinstance(layers_data, dict):\n        for layer_id, layer_meta in layers_data.items():\n            if layer_meta.get(\"schema\") != \"openpype:container-2.0\":\n                layer_meta[\"members\"] = [str(layer_id)]\n        layers_data = list(layers_data.values())\n    return layers_data\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.get_selected_layers","title":"<code>get_selected_layers()</code>","text":"<p>Get a list of actually selected layers.</p> <p>Returns:  Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def get_selected_layers(self):\n    \"\"\"Get a list of actually selected layers.\n\n    Returns: &lt;list of Layer('id':XX, 'name':\"YYY\")&gt;\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call('Photoshop.get_selected_layers')\n    )\n    return self._to_records(res)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.group_selected_layers","title":"<code>group_selected_layers(name)</code>","text":"<p>Group selected layers into new LayerSet (eg. group)</p> <p>Returns:</p> Type Description <p>(Layer)</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def group_selected_layers(self, name):\n    \"\"\"Group selected layers into new LayerSet (eg. group)\n\n    Returns:\n        (Layer)\n    \"\"\"\n    enhanced_name = self.PUBLISH_ICON + name\n    res = self.websocketserver.call(\n        self.client.call(\n            'Photoshop.group_selected_layers', name=enhanced_name\n        )\n    )\n    res = self._to_records(res)\n    if res:\n        rec = res.pop()\n        rec.name = rec.name.replace(self.PUBLISH_ICON, '')\n        return rec\n    raise ValueError(\"No group record returned\")\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.hide_all_others_layers","title":"<code>hide_all_others_layers(layers)</code>","text":"<p>hides all layers that are not part of the list or that are not children of this list</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>list</code> <p>list of PSItem - highest hierarchy</p> required Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def hide_all_others_layers(self, layers):\n    \"\"\"hides all layers that are not part of the list or that are not\n    children of this list\n\n    Args:\n        layers (list): list of PSItem - highest hierarchy\n    \"\"\"\n    extract_ids = set([ll.id for ll in self.get_layers_in_layers(layers)])\n\n    self.hide_all_others_layers_ids(extract_ids)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.hide_all_others_layers_ids","title":"<code>hide_all_others_layers_ids(extract_ids, layers=None)</code>","text":"<p>hides all layers that are not part of the list or that are not children of this list</p> <p>Parameters:</p> Name Type Description Default <code>extract_ids</code> <code>list</code> <p>list of integer that should be visible</p> required Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def hide_all_others_layers_ids(self, extract_ids, layers=None):\n    \"\"\"hides all layers that are not part of the list or that are not\n    children of this list\n\n    Args:\n        extract_ids (list): list of integer that should be visible\n        layers (list) of PSItem (used for caching)\n    \"\"\"\n    if not layers:\n        layers = self.get_layers()\n    for layer in layers:\n        if layer.visible and layer.id not in extract_ids:\n            self.set_visible(layer.id, False)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.import_smart_object","title":"<code>import_smart_object(path, layer_name, as_reference=False)</code>","text":"<p>Import the file at <code>path</code> as a smart object to active document.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>File path to import.</p> required <code>layer_name</code> <code>str</code> <p>Unique layer name to differentiate how many times same smart object was loaded</p> required <code>as_reference</code> <code>bool</code> <p>pull in content or reference</p> <code>False</code> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def import_smart_object(self, path, layer_name, as_reference=False):\n    \"\"\"Import the file at `path` as a smart object to active document.\n\n    Args:\n        path (str): File path to import.\n        layer_name (str): Unique layer name to differentiate how many times\n            same smart object was loaded\n        as_reference (bool): pull in content or reference\n    \"\"\"\n    enhanced_name = self.LOADED_ICON + layer_name\n    res = self.websocketserver.call(\n        self.client.call(\n            'Photoshop.import_smart_object',\n            path=path,\n            name=enhanced_name,\n            as_reference=as_reference\n        )\n    )\n    rec = self._to_records(res).pop()\n    if rec:\n        rec.name = rec.name.replace(self.LOADED_ICON, '')\n    return rec\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.imprint","title":"<code>imprint(item_id, data, all_layers=None, items_meta=None)</code>","text":"<p>Save layer metadata to Headline field of active document</p> <p>Stores metadata in format: [{     \"active\":true,     \"productName\":\"imageBG\",     \"productType\":\"image\",     \"id\":\"ayon.create.instance\",     \"folderPath\":\"Town\",     \"uuid\": \"8\" }] - for created instances OR [{     \"schema\": \"openpype:container-2.0\",     \"id\": \"ayon.create.instance\",     \"name\": \"imageMG\",     \"namespace\": \"Jungle_imageMG_001\",     \"loader\": \"ImageLoader\",     \"representation\": \"5fbfc0ee30a946093c6ff18a\",     \"members\": [         \"40\"     ] }] - for loaded instances</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>str</code> required <code>data(string)</code> <p>json representation for single layer</p> required <code>all_layers</code> <code>list of PSItem</code> <p>for performance, could be injected for usage in loop, if not, single call will be triggered</p> <code>None</code> <code>items_meta(string)</code> <p>json representation from Headline            (for performance - provide only if imprint is in            loop - value should be same)</p> required <p>Returns: None</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def imprint(self, item_id, data, all_layers=None, items_meta=None):\n    \"\"\"Save layer metadata to Headline field of active document\n\n    Stores metadata in format:\n    [{\n        \"active\":true,\n        \"productName\":\"imageBG\",\n        \"productType\":\"image\",\n        \"id\":\"ayon.create.instance\",\n        \"folderPath\":\"Town\",\n        \"uuid\": \"8\"\n    }] - for created instances\n    OR\n    [{\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": \"ayon.create.instance\",\n        \"name\": \"imageMG\",\n        \"namespace\": \"Jungle_imageMG_001\",\n        \"loader\": \"ImageLoader\",\n        \"representation\": \"5fbfc0ee30a946093c6ff18a\",\n        \"members\": [\n            \"40\"\n        ]\n    }] - for loaded instances\n\n    Args:\n        item_id (str):\n        data(string): json representation for single layer\n        all_layers (list of PSItem): for performance, could be\n            injected for usage in loop, if not, single call will be\n            triggered\n        items_meta(string): json representation from Headline\n                       (for performance - provide only if imprint is in\n                       loop - value should be same)\n    Returns: None\n    \"\"\"\n    if not items_meta:\n        items_meta = self.get_layers_metadata()\n\n    # json.dumps writes integer values in a dictionary to string, so\n    # anticipating it here.\n    item_id = str(item_id)\n    is_new = True\n    result_meta = []\n    for item_meta in items_meta:\n        if ((item_meta.get('members') and\n             item_id == str(item_meta.get('members')[0])) or\n                item_meta.get(\"instance_id\") == item_id):\n            is_new = False\n            if data:\n                item_meta.update(data)\n                result_meta.append(item_meta)\n        else:\n            result_meta.append(item_meta)\n\n    if is_new:\n        result_meta.append(data)\n\n    # Ensure only valid ids are stored.\n    if not all_layers:\n        all_layers = self.get_layers()\n    layer_ids = [layer.id for layer in all_layers]\n    cleaned_data = []\n\n    for item in result_meta:\n        if item.get(\"members\"):\n            if int(item[\"members\"][0]) not in layer_ids:\n                continue\n\n        cleaned_data.append(item)\n\n    payload = json.dumps(cleaned_data, indent=4)\n    self.websocketserver.call(\n        self.client.call('Photoshop.imprint', payload=payload)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.is_saved","title":"<code>is_saved()</code>","text":"<p>Returns true if no changes in active document</p> <p>Returns:</p> Type Description <p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def is_saved(self):\n    \"\"\"Returns true if no changes in active document\n\n    Returns:\n        &lt;boolean&gt;\n    \"\"\"\n    return self.websocketserver.call(\n        self.client.call('Photoshop.is_saved')\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.open","title":"<code>open(path)</code>","text":"<p>Open file located at 'path' (local).</p> <p>Parameters:</p> Name Type Description Default <code>path(string)</code> <p>file path locally</p> required <p>Returns: None</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def open(self, path):\n    \"\"\"Open file located at 'path' (local).\n\n    Args:\n        path(string): file path locally\n    Returns: None\n    \"\"\"\n    self.websocketserver.call(\n        self.client.call('Photoshop.open', path=path)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.read","title":"<code>read(layer, layers_meta=None)</code>","text":"<p>Parses layer metadata from Headline field of active document.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <p>(PSItem)</p> required <code>layers_meta</code> <p>full list from Headline (for performance in loops)</p> <code>None</code> <p>Returns:     (dict) of layer metadata stored in PS file</p> Example <p>{     'id': 'pyblish.avalon.container',     'loader': 'ImageLoader',     'members': ['64'],     'name': 'imageMainMiddle',     'namespace': 'Hero_imageMainMiddle_001',     'representation': '6203dc91e80934d9f6ee7d96',     'schema': 'openpype:container-2.0' }</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def read(self, layer, layers_meta=None):\n    \"\"\"Parses layer metadata from Headline field of active document.\n\n    Args:\n        layer: (PSItem)\n        layers_meta: full list from Headline (for performance in loops)\n    Returns:\n        (dict) of layer metadata stored in PS file\n\n    Example:\n        {\n            'id': 'pyblish.avalon.container',\n            'loader': 'ImageLoader',\n            'members': ['64'],\n            'name': 'imageMainMiddle',\n            'namespace': 'Hero_imageMainMiddle_001',\n            'representation': '6203dc91e80934d9f6ee7d96',\n            'schema': 'openpype:container-2.0'\n        }\n    \"\"\"\n    if layers_meta is None:\n        layers_meta = self.get_layers_metadata()\n\n    for layer_meta in layers_meta:\n        layer_id = layer_meta.get(\"uuid\")  # legacy\n        if layer_meta.get(\"members\"):\n            layer_id = layer_meta[\"members\"][0]\n        if str(layer.id) == str(layer_id):\n            return layer_meta\n    print(\"Unable to find layer metadata for {}\".format(layer.id))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.rename_layer","title":"<code>rename_layer(layer_id, name)</code>","text":"<p>Renames specific layer by it's id.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>id of layer to delete</p> required <code>name</code> <code>str</code> <p>new name</p> required Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def rename_layer(self, layer_id, name):\n    \"\"\"Renames specific layer by it's id.\n\n    Args:\n        layer_id (int): id of layer to delete\n        name (str): new name\n    \"\"\"\n    self.websocketserver.call(\n        self.client.call(\n            'Photoshop.rename_layer',\n            layer_id=layer_id,\n            name=name\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.replace_smart_object","title":"<code>replace_smart_object(layer, path, layer_name)</code>","text":"<p>Replace the smart object <code>layer</code> with file at <code>path</code></p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>PSItem</code> required <code>path</code> <code>str</code> <p>File to import.</p> required <code>layer_name</code> <code>str</code> <p>Unique layer name to differentiate how many times same smart object was loaded</p> required Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def replace_smart_object(self, layer, path, layer_name):\n    \"\"\"Replace the smart object `layer` with file at `path`\n\n    Args:\n        layer (PSItem):\n        path (str): File to import.\n        layer_name (str): Unique layer name to differentiate how many times\n            same smart object was loaded\n    \"\"\"\n    enhanced_name = self.LOADED_ICON + layer_name\n    self.websocketserver.call(\n        self.client.call(\n            'Photoshop.replace_smart_object',\n            layer_id=layer.id,\n            path=path,\n            name=enhanced_name\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.save","title":"<code>save()</code>","text":"<p>Saves active document</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def save(self):\n    \"\"\"Saves active document\"\"\"\n    self.websocketserver.call(\n        self.client.call('Photoshop.save')\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.saveAs","title":"<code>saveAs(image_path, ext, as_copy)</code>","text":"<p>Saves active document to psd (copy) or png or jpg</p> <p>Parameters:</p> Name Type Description Default <code>image_path(string)</code> <p>full local path</p> required <code>ext</code> <p> required <code>as_copy</code> <p> required <p>Returns: None</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def saveAs(self, image_path, ext, as_copy):\n    \"\"\"Saves active document to psd (copy) or png or jpg\n\n    Args:\n        image_path(string): full local path\n        ext: &lt;string psd|jpg|png&gt;\n        as_copy: &lt;boolean&gt;\n    Returns: None\n    \"\"\"\n    self.websocketserver.call(\n        self.client.call(\n            'Photoshop.saveAs',\n            image_path=image_path,\n            ext=ext,\n            as_copy=as_copy\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.select_layers","title":"<code>select_layers(layers)</code>","text":"<p>Selects specified layers in Photoshop by its ids.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <p> required Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def select_layers(self, layers):\n    \"\"\"Selects specified layers in Photoshop by its ids.\n\n    Args:\n        layers: &lt;list of Layer('id':XX, 'name':\"YYY\")&gt;\n    \"\"\"\n    layers_id = [str(lay.id) for lay in layers]\n    self.websocketserver.call(\n        self.client.call(\n            'Photoshop.select_layers',\n            layers=json.dumps(layers_id)\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/api/ws_stub.html#client.ayon_photoshop.api.ws_stub.PhotoshopServerStub.set_visible","title":"<code>set_visible(layer_id, visibility)</code>","text":"<p>Set layer with 'layer_id' to 'visibility'</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <p> required <code>visibility</code> <p> required <p>Returns: None</p> Source code in <code>client/ayon_photoshop/api/ws_stub.py</code> <pre><code>def set_visible(self, layer_id, visibility):\n    \"\"\"Set layer with 'layer_id' to 'visibility'\n\n    Args:\n        layer_id: &lt;int&gt;\n        visibility: &lt;true - set visible, false - hide&gt;\n    Returns: None\n    \"\"\"\n    self.websocketserver.call(\n        self.client.call(\n            'Photoshop.set_visible',\n            layer_id=layer_id,\n            visibility=visibility\n        )\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_photoshop/hooks/pre_launch_args.html","title":"pre_launch_args","text":""},{"location":"autoapi/client/ayon_photoshop/hooks/pre_launch_args.html#client.ayon_photoshop.hooks.pre_launch_args.PhotoshopPrelaunchHook","title":"<code>PhotoshopPrelaunchHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch arguments preparation.</p> <p>Hook add python executable and script path to Photoshop implementation before Photoshop executable and add last workfile path to launch arguments.</p> <p>Existence of last workfile is checked. If workfile does not exists tries to copy templated workfile from predefined path.</p> Source code in <code>client/ayon_photoshop/hooks/pre_launch_args.py</code> <pre><code>class PhotoshopPrelaunchHook(PreLaunchHook):\n    \"\"\"Launch arguments preparation.\n\n    Hook add python executable and script path to Photoshop implementation\n    before Photoshop executable and add last workfile path to launch arguments.\n\n    Existence of last workfile is checked. If workfile does not exists tries\n    to copy templated workfile from predefined path.\n    \"\"\"\n    app_groups = {\"photoshop\"}\n\n    order = 20\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Pop executable\n        executable_path = self.launch_context.launch_args.pop(0)\n\n        # Pop rest of launch arguments - There should not be other arguments!\n        remainders = []\n        while self.launch_context.launch_args:\n            remainders.append(self.launch_context.launch_args.pop(0))\n\n        script_path = get_launch_script_path()\n\n        new_launch_args = get_ayon_launcher_args(\n            \"run\", script_path, executable_path\n        )\n        # Add workfile path if exists\n        workfile_path = self.data[\"last_workfile_path\"]\n        if (\n            self.data.get(\"start_last_workfile\")\n            and workfile_path\n            and os.path.exists(workfile_path)\n        ):\n            new_launch_args.append(workfile_path)\n\n        # Append as whole list as these arguments should not be separated\n        self.launch_context.launch_args.append(new_launch_args)\n\n        if remainders:\n            self.launch_context.launch_args.extend(remainders)\n\n        self.launch_context.kwargs = get_launch_kwargs(\n            self.launch_context.kwargs\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/hooks/pre_launch_args.html#client.ayon_photoshop.hooks.pre_launch_args.get_launch_kwargs","title":"<code>get_launch_kwargs(kwargs)</code>","text":"<p>Explicit setting of kwargs for Popen for Photoshop.</p> <p>Expected behavior - ayon_console opens window with logs - ayon has stdout/stderr available for capturing</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Union[dict, None]</code> <p>Current kwargs or None.</p> required Source code in <code>client/ayon_photoshop/hooks/pre_launch_args.py</code> <pre><code>def get_launch_kwargs(kwargs):\n    \"\"\"Explicit setting of kwargs for Popen for Photoshop.\n\n    Expected behavior\n    - ayon_console opens window with logs\n    - ayon has stdout/stderr available for capturing\n\n    Args:\n        kwargs (Union[dict, None]): Current kwargs or None.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    if platform.system().lower() != \"windows\":\n        return kwargs\n\n    if is_using_ayon_console():\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE\n        })\n    else:\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NO_WINDOW,\n            \"stdout\": subprocess.DEVNULL,\n            \"stderr\": subprocess.DEVNULL\n        })\n    return kwargs\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/create/create_flatten_image.html","title":"create_flatten_image","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/create/create_flatten_image.html#client.ayon_photoshop.plugins.create.create_flatten_image.AutoImageCreator","title":"<code>AutoImageCreator</code>","text":"<p>               Bases: <code>PSAutoCreator</code></p> <p>Creates flatten image from all visible layers.</p> <p>Used in simplified publishing as auto created instance. Must be enabled in Setting and template for product name provided</p> Source code in <code>client/ayon_photoshop/plugins/create/create_flatten_image.py</code> <pre><code>class AutoImageCreator(PSAutoCreator):\n    \"\"\"Creates flatten image from all visible layers.\n\n    Used in simplified publishing as auto created instance.\n    Must be enabled in Setting and template for product name provided\n    \"\"\"\n    identifier = \"auto_image\"\n    product_type = \"image\"\n\n    # Settings\n    default_variant = \"\"\n    # - Mark by default instance for review\n    mark_for_review = True\n    active_on_create = True\n\n    def create(self, options=None):\n        existing_instance = None\n        for instance in self.create_context.instances:\n            if instance.creator_identifier == self.identifier:\n                existing_instance = instance\n                break\n\n        context = self.create_context\n        project_name = context.get_current_project_name()\n        folder_path = context.get_current_folder_path()\n        task_name = context.get_current_task_name()\n        host_name = context.host_name\n        folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n        task_entity = ayon_api.get_task_by_name(\n            project_name, folder_entity[\"id\"], task_name\n        )\n\n        existing_folder_path = None\n        if existing_instance is not None:\n            existing_folder_path = existing_instance[\"folderPath\"]\n\n        if existing_instance is None:\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n            )\n\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n            }\n\n            if not self.active_on_create:\n                data[\"active\"] = False\n\n            creator_attributes = {\"mark_for_review\": self.mark_for_review}\n            data.update({\"creator_attributes\": creator_attributes})\n\n            new_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n            self._add_instance_to_context(new_instance)\n            api.stub().imprint(new_instance.get(\"instance_id\"),\n                               new_instance.data_to_store())\n\n        elif (  # existing instance from different context\n            existing_folder_path != folder_path\n            or existing_instance[\"task\"] != task_name\n        ):\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                self.default_variant,\n                host_name,\n            )\n            existing_instance[\"folderPath\"] = folder_path\n            existing_instance[\"task\"] = task_name\n            existing_instance[\"productName\"] = product_name\n\n            api.stub().imprint(existing_instance.get(\"instance_id\"),\n                               existing_instance.data_to_store())\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=self.mark_for_review\n            )\n        ]\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\"\n            )\n        ]\n\n    def apply_settings(self, project_settings):\n        plugin_settings = (\n            project_settings[\"photoshop\"][\"create\"][\"AutoImageCreator\"]\n        )\n\n        self.active_on_create = plugin_settings[\"active_on_create\"]\n        self.default_variant = plugin_settings[\"default_variant\"]\n        self.mark_for_review = plugin_settings[\"mark_for_review\"]\n        self.enabled = plugin_settings[\"enabled\"]\n\n    def get_detail_description(self):\n        return \"\"\"Creator for flatten image.\n\n        Studio might configure simple publishing workflow. In that case\n        `image` instance is automatically created which will publish flat\n        image from all visible layers.\n\n        Artist might disable this instance from publishing or from creating\n        review for it though.\n        \"\"\"\n\n    def get_product_name(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name=None,\n        instance=None\n    ):\n        if host_name is None:\n            host_name = self.create_context.host_name\n\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n\n        dynamic_data = prepare_template_data({\"layer\": \"{layer}\"})\n\n        product_name = get_product_name(\n            project_name,\n            task_name,\n            task_type,\n            host_name,\n            self.product_type,\n            variant,\n            dynamic_data=dynamic_data\n        )\n        return clean_product_name(product_name)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/create/create_image.html","title":"create_image","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/create/create_image.html#client.ayon_photoshop.plugins.create.create_image.ImageCreator","title":"<code>ImageCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Creates image instance for publishing.</p> <p>Result of 'image' instance is image of all visible layers, or image(s) of selected layers.</p> Source code in <code>client/ayon_photoshop/plugins/create/create_image.py</code> <pre><code>class ImageCreator(Creator):\n    \"\"\"Creates image instance for publishing.\n\n    Result of 'image' instance is image of all visible layers, or image(s) of\n    selected layers.\n    \"\"\"\n    identifier = \"image\"\n    label = \"Image\"\n    product_type = \"image\"\n    description = \"Image creator\"\n\n    # Settings\n    default_variants = \"\"\n    mark_for_review = False\n    active_on_create = True\n\n    def create(self, product_name_from_ui, data, pre_create_data):\n        groups_to_create = []\n        top_layers_to_wrap = []\n        create_empty_group = False\n\n        stub = api.stub()  # only after PS is up\n        if pre_create_data.get(\"use_selection\"):\n            try:\n                top_level_selected_items = stub.get_selected_layers()\n            except ValueError:\n                raise CreatorError(\"Cannot group locked Background layer!\")\n\n            only_single_item_selected = len(top_level_selected_items) == 1\n            if (\n                    only_single_item_selected or\n                    pre_create_data.get(\"create_multiple\")):\n                for selected_item in top_level_selected_items:\n                    if selected_item.group:\n                        groups_to_create.append(selected_item)\n                    else:\n                        top_layers_to_wrap.append(selected_item)\n            else:\n                group = stub.group_selected_layers(product_name_from_ui)\n                groups_to_create.append(group)\n        else:\n            try:\n                stub.select_layers(stub.get_layers())\n                group = stub.group_selected_layers(product_name_from_ui)\n            except ValueError:\n                raise CreatorError(\"Cannot group locked Background layer!\")\n\n            groups_to_create.append(group)\n\n        # create empty group if nothing selected\n        if not groups_to_create and not top_layers_to_wrap:\n            group = stub.create_group(product_name_from_ui)\n            groups_to_create.append(group)\n\n        # wrap each top level layer into separate new group\n        for layer in top_layers_to_wrap:\n            stub.select_layers([layer])\n            group = stub.group_selected_layers(layer.name)\n            groups_to_create.append(group)\n\n        layer_name = ''\n        # use artist chosen option OR force layer if more products are created\n        # to differentiate them\n        use_layer_name = (pre_create_data.get(\"use_layer_name\") or\n                          len(groups_to_create) &gt; 1)\n        for group in groups_to_create:\n            product_name = product_name_from_ui  # reset to name from creator UI\n            layer_names_in_hierarchy = []\n            created_group_name = self._clean_highlights(stub, group.name)\n\n            if use_layer_name:\n                layer_name = re.sub(\n                    \"[^{}]+\".format(PRODUCT_NAME_ALLOWED_SYMBOLS),\n                    \"\",\n                    group.name\n                )\n                if \"{layer}\" not in product_name.lower():\n                    product_name += \"{Layer}\"\n\n            layer_fill = prepare_template_data({\"layer\": layer_name})\n            product_name = product_name.format(**layer_fill)\n            product_name = clean_product_name(product_name)\n\n            if group.long_name:\n                for directory in group.long_name[::-1]:\n                    name = self._clean_highlights(stub, directory)\n                    layer_names_in_hierarchy.append(name)\n\n            data_update = {\n                \"productName\": product_name,\n                \"members\": [str(group.id)],\n                \"layer_name\": layer_name,\n                \"long_name\": \"_\".join(layer_names_in_hierarchy)\n            }\n            data.update(data_update)\n\n            mark_for_review = (pre_create_data.get(\"mark_for_review\") or\n                               self.mark_for_review)\n            creator_attributes = {\"mark_for_review\": mark_for_review}\n            data.update({\"creator_attributes\": creator_attributes})\n\n            if not self.active_on_create:\n                data[\"active\"] = False\n\n            new_instance = CreatedInstance(\n                self.product_type, product_name, data, self\n            )\n\n            stub.imprint(new_instance.get(\"instance_id\"),\n                         new_instance.data_to_store())\n            self._add_instance_to_context(new_instance)\n            # reusing existing group, need to rename afterwards\n            if not create_empty_group:\n                stub.rename_layer(group.id,\n                                  stub.PUBLISH_ICON + created_group_name)\n\n    def collect_instances(self):\n        for instance_data in cache_and_get_instances(self):\n            # legacy instances have family=='image'\n            creator_id = (instance_data.get(\"creator_identifier\") or\n                          instance_data.get(\"family\"))\n\n            if creator_id == self.identifier:\n                instance_data = self._handle_legacy(instance_data)\n                instance = CreatedInstance.from_existing(\n                    instance_data, self\n                )\n                self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        self.log.debug(\"update_list:: {}\".format(update_list))\n        for created_inst, _changes in update_list:\n            if created_inst.get(\"layer\"):\n                # not storing PSItem layer to metadata\n                created_inst.pop(\"layer\")\n            api.stub().imprint(created_inst.get(\"instance_id\"),\n                               created_inst.data_to_store())\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            self.host.remove_instance(instance)\n            self._remove_instance_from_context(instance)\n\n    def get_pre_create_attr_defs(self):\n        output = [\n            BoolDef(\"use_selection\", default=True,\n                    label=\"Create only for selected\"),\n            BoolDef(\"create_multiple\",\n                    default=True,\n                    label=\"Create separate instance for each selected\"),\n            BoolDef(\"use_layer_name\",\n                    default=False,\n                    label=\"Use layer name in product\"),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Create separate review\",\n                default=False\n            )\n        ]\n        return output\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\"\n            )\n        ]\n\n    def apply_settings(self, project_settings):\n        plugin_settings = (\n            project_settings[\"photoshop\"][\"create\"][\"ImageCreator\"]\n        )\n\n        self.active_on_create = plugin_settings[\"active_on_create\"]\n        self.default_variants = plugin_settings[\"default_variants\"]\n        self.mark_for_review = plugin_settings[\"mark_for_review\"]\n        self.enabled = plugin_settings[\"enabled\"]\n\n    def get_detail_description(self):\n        return \"\"\"Creator for Image instances\n\n        Main publishable item in Photoshop will be of `image` product type.\n        Result of this item (instance) is picture that could be loaded and\n        used in another DCCs (for example as single layer in composition in\n        AfterEffects, reference in Maya etc).\n\n        There are couple of options what to publish:\n        - separate image per selected layer (or group of layers)\n        - one image for all selected layers\n        - all visible layers (groups) flattened into single image\n\n        In most cases you would like to keep `Create only for selected`\n        toggled on and select what you would like to publish.\n        Toggling this option off will allow you to create instance for all\n        visible layers without a need to select them explicitly.\n\n        Use 'Create separate instance for each selected' to create separate\n        images per selected layer (group of layers).\n\n        'Use layer name in product' will explicitly add layer name into\n        product name. Position of this name is configurable in\n        `project_settings/global/tools/creator/product_name_profiles`.\n        If layer placeholder ({layer}) is not used in `product_name_profiles`\n        but layer name should be used (set explicitly in UI or implicitly if\n        multiple images should be created), it is added in capitalized form\n        as a suffix to product name.\n\n        Each image could have its separate review created if necessary via\n        `Create separate review` toggle.\n        But more use case is to use separate `review` instance to create review\n        from all published items.\n        \"\"\"\n\n    def _handle_legacy(self, instance_data):\n        \"\"\"Converts old instances to new format.\"\"\"\n        if not instance_data.get(\"members\"):\n            instance_data[\"members\"] = [instance_data.get(\"uuid\")]\n\n        if instance_data.get(\"uuid\"):\n            # uuid not needed, replaced with unique instance_id\n            api.stub().remove_instance(instance_data.get(\"uuid\"))\n            instance_data.pop(\"uuid\")\n\n        if not instance_data.get(\"task\"):\n            instance_data[\"task\"] = self.create_context.get_current_task_name()\n\n        if not instance_data.get(\"variant\"):\n            instance_data[\"variant\"] = ''\n\n        return instance_data\n\n    def _clean_highlights(self, stub, item):\n        return item.replace(stub.PUBLISH_ICON, '').replace(stub.LOADED_ICON,\n                                                           '')\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        if instance is not None:\n            layer_name = instance.get(\"layer_name\")\n            if layer_name:\n                return {\"layer\": layer_name}\n        return {\"layer\": \"{layer}\"}\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/create/create_review.html","title":"create_review","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/create/create_review.html#client.ayon_photoshop.plugins.create.create_review.ReviewCreator","title":"<code>ReviewCreator</code>","text":"<p>               Bases: <code>PSAutoCreator</code></p> <p>Creates review instance which might be disabled from publishing.</p> Source code in <code>client/ayon_photoshop/plugins/create/create_review.py</code> <pre><code>class ReviewCreator(PSAutoCreator):\n    \"\"\"Creates review instance which might be disabled from publishing.\"\"\"\n    identifier = \"review\"\n    product_type = \"review\"\n\n    default_variant = \"Main\"\n\n    def get_detail_description(self):\n        return \"\"\"Auto creator for review.\n\n        Photoshop review is created from all published images or from all\n        visible layers if no `image` instances got created.\n\n        Review might be disabled by an artist (instance shouldn't be deleted as\n        it will get recreated in next publish either way).\n        \"\"\"\n\n    def apply_settings(self, project_settings):\n        plugin_settings = (\n            project_settings[\"photoshop\"][\"create\"][\"ReviewCreator\"]\n        )\n\n        self.default_variant = plugin_settings[\"default_variant\"]\n        self.active_on_create = plugin_settings[\"active_on_create\"]\n        self.enabled = plugin_settings[\"enabled\"]\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image.html","title":"load_image","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image.html#client.ayon_photoshop.plugins.load.load_image.ImageLoader","title":"<code>ImageLoader</code>","text":"<p>               Bases: <code>PhotoshopLoader</code></p> <p>Load images</p> <p>Stores the imported asset in a container named after the asset.</p> Source code in <code>client/ayon_photoshop/plugins/load/load_image.py</code> <pre><code>class ImageLoader(photoshop.PhotoshopLoader):\n    \"\"\"Load images\n\n    Stores the imported asset in a container named after the asset.\n    \"\"\"\n\n    product_types = {\"image\", \"render\"}\n    representations = {\"*\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n        stub = self.get_stub()\n        layer_name = get_unique_layer_name(\n            stub.get_layers(),\n            context[\"folder\"][\"name\"],\n            name\n        )\n        with photoshop.maintained_selection():\n            path = self.filepath_from_context(context)\n            layer = self.import_layer(path, layer_name, stub)\n\n        self[:] = [layer]\n        namespace = namespace or layer_name\n\n        return photoshop.containerise(\n            name,\n            namespace,\n            layer,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        \"\"\" Switch asset or change version \"\"\"\n        stub = self.get_stub()\n\n        layer = container.pop(\"layer\")\n\n        repre_entity = context[\"representation\"]\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n\n        namespace_from_container = re.sub(r'_\\d{3}$', '',\n                                          container[\"namespace\"])\n        layer_name = \"{}_{}\".format(folder_name, product_name)\n        # switching assets\n        if namespace_from_container != layer_name:\n            layer_name = get_unique_layer_name(\n                stub.get_layers(), folder_name, product_name\n            )\n        else:  # switching version - keep same name\n            layer_name = container[\"namespace\"]\n\n        path = get_representation_path(repre_entity)\n        with photoshop.maintained_selection():\n            stub.replace_smart_object(\n                layer, path, layer_name\n            )\n\n        stub.imprint(\n            layer.id, {\"representation\": repre_entity[\"id\"]}\n        )\n\n    def remove(self, container):\n        \"\"\"\n            Removes element from scene: deletes layer + removes from Headline\n        Args:\n            container (dict): container to be removed - used to get layer_id\n        \"\"\"\n        stub = self.get_stub()\n\n        layer = container.pop(\"layer\")\n        stub.imprint(layer.id, {})\n        stub.delete_layer(layer.id)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def import_layer(self, file_name, layer_name, stub):\n        return stub.import_smart_object(file_name, layer_name)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image.html#client.ayon_photoshop.plugins.load.load_image.ImageLoader.remove","title":"<code>remove(container)</code>","text":"<pre><code>Removes element from scene: deletes layer + removes from Headline\n</code></pre> <p>Args:     container (dict): container to be removed - used to get layer_id</p> Source code in <code>client/ayon_photoshop/plugins/load/load_image.py</code> <pre><code>def remove(self, container):\n    \"\"\"\n        Removes element from scene: deletes layer + removes from Headline\n    Args:\n        container (dict): container to be removed - used to get layer_id\n    \"\"\"\n    stub = self.get_stub()\n\n    layer = container.pop(\"layer\")\n    stub.imprint(layer.id, {})\n    stub.delete_layer(layer.id)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image.html#client.ayon_photoshop.plugins.load.load_image.ImageLoader.update","title":"<code>update(container, context)</code>","text":"<p>Switch asset or change version</p> Source code in <code>client/ayon_photoshop/plugins/load/load_image.py</code> <pre><code>def update(self, container, context):\n    \"\"\" Switch asset or change version \"\"\"\n    stub = self.get_stub()\n\n    layer = container.pop(\"layer\")\n\n    repre_entity = context[\"representation\"]\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n\n    namespace_from_container = re.sub(r'_\\d{3}$', '',\n                                      container[\"namespace\"])\n    layer_name = \"{}_{}\".format(folder_name, product_name)\n    # switching assets\n    if namespace_from_container != layer_name:\n        layer_name = get_unique_layer_name(\n            stub.get_layers(), folder_name, product_name\n        )\n    else:  # switching version - keep same name\n        layer_name = container[\"namespace\"]\n\n    path = get_representation_path(repre_entity)\n    with photoshop.maintained_selection():\n        stub.replace_smart_object(\n            layer, path, layer_name\n        )\n\n    stub.imprint(\n        layer.id, {\"representation\": repre_entity[\"id\"]}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image_from_sequence.html","title":"load_image_from_sequence","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image_from_sequence.html#client.ayon_photoshop.plugins.load.load_image_from_sequence.ImageFromSequenceLoader","title":"<code>ImageFromSequenceLoader</code>","text":"<p>               Bases: <code>PhotoshopLoader</code></p> <p>Load specific image from sequence</p> <p>Used only as quick load of reference file from a sequence.</p> <p>Plain ImageLoader picks first frame from sequence.</p> <p>Loads only existing files - currently not possible to limit loaders to single select - multiselect. If user selects multiple repres, list for all of them is provided, but selection is only single file. This loader will be triggered multiple times, but selected name will match only to proper path.</p> <p>Loader doesn't do containerization as there is currently no data model of 'frame of rendered files' (only rendered sequence), update would be difficult.</p> Source code in <code>client/ayon_photoshop/plugins/load/load_image_from_sequence.py</code> <pre><code>class ImageFromSequenceLoader(photoshop.PhotoshopLoader):\n    \"\"\" Load specific image from sequence\n\n        Used only as quick load of reference file from a sequence.\n\n        Plain ImageLoader picks first frame from sequence.\n\n        Loads only existing files - currently not possible to limit loaders\n        to single select - multiselect. If user selects multiple repres, list\n        for all of them is provided, but selection is only single file.\n        This loader will be triggered multiple times, but selected name will\n        match only to proper path.\n\n        Loader doesn't do containerization as there is currently no data model\n        of 'frame of rendered files' (only rendered sequence), update would be\n        difficult.\n    \"\"\"\n\n    product_types = {\"render\"}\n    representations = {\"*\"}\n    options = []\n\n    def load(self, context, name=None, namespace=None, data=None):\n\n        path = self.filepath_from_context(context)\n        if data.get(\"frame\"):\n            path = os.path.join(\n                os.path.dirname(path), data[\"frame\"]\n            )\n            if not os.path.exists(path):\n                return\n\n        stub = self.get_stub()\n        layer_name = get_unique_layer_name(\n            stub.get_layers(), context[\"folder\"][\"name\"], name\n        )\n\n        with photoshop.maintained_selection():\n            layer = stub.import_smart_object(path, layer_name)\n\n        self[:] = [layer]\n        namespace = namespace or layer_name\n\n        return namespace\n\n    @classmethod\n    def get_options(cls, repre_contexts):\n        \"\"\"\n            Returns list of files for selected 'repre_contexts'.\n\n            It returns only files with same extension as in context as it is\n            expected that context points to sequence of frames.\n\n            Returns:\n                (list) of qargparse.Choice\n        \"\"\"\n        files = []\n        for context in repre_contexts:\n            fname = cls.filepath_from_context(context)\n            _, file_extension = os.path.splitext(fname)\n\n            for file_name in os.listdir(os.path.dirname(fname)):\n                if not file_name.endswith(file_extension):\n                    continue\n                files.append(file_name)\n\n        # return selection only if there is something\n        if not files or len(files) &lt;= 1:\n            return []\n\n        return [\n            qargparse.Choice(\n                \"frame\",\n                label=\"Select specific file\",\n                items=files,\n                default=0,\n                help=\"Which frame should be loaded?\"\n            )\n        ]\n\n    def update(self, container, context):\n        \"\"\"No update possible, not containerized.\"\"\"\n        pass\n\n    def remove(self, container):\n        \"\"\"No update possible, not containerized.\"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image_from_sequence.html#client.ayon_photoshop.plugins.load.load_image_from_sequence.ImageFromSequenceLoader.get_options","title":"<code>get_options(repre_contexts)</code>  <code>classmethod</code>","text":"<p>Returns list of files for selected 'repre_contexts'.</p> <p>It returns only files with same extension as in context as it is expected that context points to sequence of frames.</p> <p>Returns:</p> Type Description <p>(list) of qargparse.Choice</p> Source code in <code>client/ayon_photoshop/plugins/load/load_image_from_sequence.py</code> <pre><code>@classmethod\ndef get_options(cls, repre_contexts):\n    \"\"\"\n        Returns list of files for selected 'repre_contexts'.\n\n        It returns only files with same extension as in context as it is\n        expected that context points to sequence of frames.\n\n        Returns:\n            (list) of qargparse.Choice\n    \"\"\"\n    files = []\n    for context in repre_contexts:\n        fname = cls.filepath_from_context(context)\n        _, file_extension = os.path.splitext(fname)\n\n        for file_name in os.listdir(os.path.dirname(fname)):\n            if not file_name.endswith(file_extension):\n                continue\n            files.append(file_name)\n\n    # return selection only if there is something\n    if not files or len(files) &lt;= 1:\n        return []\n\n    return [\n        qargparse.Choice(\n            \"frame\",\n            label=\"Select specific file\",\n            items=files,\n            default=0,\n            help=\"Which frame should be loaded?\"\n        )\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image_from_sequence.html#client.ayon_photoshop.plugins.load.load_image_from_sequence.ImageFromSequenceLoader.remove","title":"<code>remove(container)</code>","text":"<p>No update possible, not containerized.</p> Source code in <code>client/ayon_photoshop/plugins/load/load_image_from_sequence.py</code> <pre><code>def remove(self, container):\n    \"\"\"No update possible, not containerized.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_image_from_sequence.html#client.ayon_photoshop.plugins.load.load_image_from_sequence.ImageFromSequenceLoader.update","title":"<code>update(container, context)</code>","text":"<p>No update possible, not containerized.</p> Source code in <code>client/ayon_photoshop/plugins/load/load_image_from_sequence.py</code> <pre><code>def update(self, container, context):\n    \"\"\"No update possible, not containerized.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_reference.html","title":"load_reference","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_reference.html#client.ayon_photoshop.plugins.load.load_reference.ReferenceLoader","title":"<code>ReferenceLoader</code>","text":"<p>               Bases: <code>PhotoshopLoader</code></p> <p>Load reference images</p> <p>Stores the imported asset in a container named after the asset.</p> <p>Inheriting from 'load_image' didn't work because of \"Cannot write to closing transport\", possible refactor.</p> Source code in <code>client/ayon_photoshop/plugins/load/load_reference.py</code> <pre><code>class ReferenceLoader(photoshop.PhotoshopLoader):\n    \"\"\"Load reference images\n\n    Stores the imported asset in a container named after the asset.\n\n    Inheriting from 'load_image' didn't work because of\n    \"Cannot write to closing transport\", possible refactor.\n    \"\"\"\n\n    product_types = {\"image\", \"render\"}\n    representations = {\"*\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n        stub = self.get_stub()\n        layer_name = get_unique_layer_name(\n            stub.get_layers(), context[\"folder\"][\"name\"], name\n        )\n        with photoshop.maintained_selection():\n            path = self.filepath_from_context(context)\n            layer = self.import_layer(path, layer_name, stub)\n\n        self[:] = [layer]\n        namespace = namespace or layer_name\n\n        return photoshop.containerise(\n            name,\n            namespace,\n            layer,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        \"\"\" Switch asset or change version.\"\"\"\n        stub = self.get_stub()\n        layer = container.pop(\"layer\")\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        repre_entity = context[\"representation\"]\n\n        namespace_from_container = re.sub(r'_\\d{3}$', '',\n                                          container[\"namespace\"])\n        layer_name = \"{}_{}\".format(folder_name, product_name)\n        # switching assets\n        if namespace_from_container != layer_name:\n            layer_name = get_unique_layer_name(\n                stub.get_layers(), folder_name, product_name\n            )\n        else:  # switching version - keep same name\n            layer_name = container[\"namespace\"]\n\n        path = get_representation_path(repre_entity)\n        with photoshop.maintained_selection():\n            stub.replace_smart_object(\n                layer, path, layer_name\n            )\n\n        stub.imprint(\n            layer.id, {\"representation\": repre_entity[\"id\"]}\n        )\n\n    def remove(self, container):\n        \"\"\"Removes element from scene: deletes layer + removes from Headline\n\n        Args:\n            container (dict): container to be removed - used to get layer_id\n        \"\"\"\n        stub = self.get_stub()\n        layer = container.pop(\"layer\")\n        stub.imprint(layer.id, {})\n        stub.delete_layer(layer.id)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def import_layer(self, file_name, layer_name, stub):\n        return stub.import_smart_object(\n            file_name, layer_name, as_reference=True\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_reference.html#client.ayon_photoshop.plugins.load.load_reference.ReferenceLoader.remove","title":"<code>remove(container)</code>","text":"<p>Removes element from scene: deletes layer + removes from Headline</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>dict</code> <p>container to be removed - used to get layer_id</p> required Source code in <code>client/ayon_photoshop/plugins/load/load_reference.py</code> <pre><code>def remove(self, container):\n    \"\"\"Removes element from scene: deletes layer + removes from Headline\n\n    Args:\n        container (dict): container to be removed - used to get layer_id\n    \"\"\"\n    stub = self.get_stub()\n    layer = container.pop(\"layer\")\n    stub.imprint(layer.id, {})\n    stub.delete_layer(layer.id)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/load/load_reference.html#client.ayon_photoshop.plugins.load.load_reference.ReferenceLoader.update","title":"<code>update(container, context)</code>","text":"<p>Switch asset or change version.</p> Source code in <code>client/ayon_photoshop/plugins/load/load_reference.py</code> <pre><code>def update(self, container, context):\n    \"\"\" Switch asset or change version.\"\"\"\n    stub = self.get_stub()\n    layer = container.pop(\"layer\")\n\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n    repre_entity = context[\"representation\"]\n\n    namespace_from_container = re.sub(r'_\\d{3}$', '',\n                                      container[\"namespace\"])\n    layer_name = \"{}_{}\".format(folder_name, product_name)\n    # switching assets\n    if namespace_from_container != layer_name:\n        layer_name = get_unique_layer_name(\n            stub.get_layers(), folder_name, product_name\n        )\n    else:  # switching version - keep same name\n        layer_name = container[\"namespace\"]\n\n    path = get_representation_path(repre_entity)\n    with photoshop.maintained_selection():\n        stub.replace_smart_object(\n            layer, path, layer_name\n        )\n\n    stub.imprint(\n        layer.id, {\"representation\": repre_entity[\"id\"]}\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/closePS.html","title":"closePS","text":"<p>Close PS after publish. For Webpublishing only.</p>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/closePS.html#client.ayon_photoshop.plugins.publish.closePS.ClosePS","title":"<code>ClosePS</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Close PS after publish. For Webpublishing only.</p> Source code in <code>client/ayon_photoshop/plugins/publish/closePS.py</code> <pre><code>class ClosePS(pyblish.api.ContextPlugin):\n    \"\"\"Close PS after publish. For Webpublishing only.\n    \"\"\"\n\n    order = pyblish.api.IntegratorOrder + 14\n    label = \"Close PS\"\n    optional = True\n    active = True\n\n    hosts = [\"photoshop\"]\n    targets = [\"automated\"]\n\n    def process(self, context):\n        self.log.info(\"ClosePS\")\n\n        stub = photoshop.stub()\n        self.log.info(\"Shutting down PS\")\n        stub.save()\n        stub.close()\n        self.log.info(\"PS closed\")\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_image.html","title":"collect_auto_image","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_image.html#client.ayon_photoshop.plugins.publish.collect_auto_image.CollectAutoImage","title":"<code>CollectAutoImage</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Creates auto image in non artist based publishes (Webpublisher).</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_auto_image.py</code> <pre><code>class CollectAutoImage(pyblish.api.ContextPlugin):\n    \"\"\"Creates auto image in non artist based publishes (Webpublisher).\n    \"\"\"\n\n    label = \"Collect Auto Image\"\n    hosts = [\"photoshop\"]\n    order = pyblish.api.CollectorOrder + 0.2\n\n    targets = [\"automated\"]\n\n    def process(self, context):\n        for instance in context:\n            creator_identifier = instance.data.get(\"creator_identifier\")\n            if creator_identifier and creator_identifier == \"auto_image\":\n                self.log.debug(\"Auto image instance found, won't create new\")\n                return\n\n        project_name = context.data[\"projectName\"]\n        proj_settings = context.data[\"project_settings\"]\n        host_name = context.data[\"hostName\"]\n        folder_entity = context.data[\"folderEntity\"]\n        task_entity = context.data[\"taskEntity\"]\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n\n        auto_creator = proj_settings.get(\n            \"photoshop\", {}).get(\n            \"create\", {}).get(\n            \"AutoImageCreator\", {})\n\n        if not auto_creator or not auto_creator[\"enabled\"]:\n            self.log.debug(\"Auto image creator disabled, won't create new\")\n            return\n\n        stub = photoshop.stub()\n        stored_items = stub.get_layers_metadata()\n        for item in stored_items:\n            if item.get(\"creator_identifier\") == \"auto_image\":\n                if not item.get(\"active\"):\n                    self.log.debug(\"Auto_image instance disabled\")\n                    return\n\n        layer_items = stub.get_layers()\n\n        publishable_ids = [layer.id for layer in layer_items\n                           if layer.visible]\n\n        # collect stored image instances\n        instance_names = []\n        for layer_item in layer_items:\n            layer_meta_data = stub.read(layer_item, stored_items)\n\n            # Skip layers without metadata.\n            if layer_meta_data is None:\n                continue\n\n            # Skip containers.\n            if \"container\" in layer_meta_data[\"id\"]:\n                continue\n\n            # active might not be in legacy meta\n            if layer_meta_data.get(\"active\", True) and layer_item.visible:\n                instance_names.append(layer_meta_data[\"productName\"])\n\n        if len(instance_names) == 0:\n            variants = proj_settings.get(\n                \"photoshop\", {}).get(\n                \"create\", {}).get(\n                \"CreateImage\", {}).get(\n                \"default_variants\", [''])\n            product_type = \"image\"\n\n            variant = context.data.get(\"variant\") or variants[0]\n\n            product_name = get_product_name(\n                project_name,\n                task_name,\n                task_type,\n                host_name,\n                product_type,\n                variant,\n            )\n\n            instance = context.create_instance(product_name)\n            instance.data[\"folderPath\"] = folder_entity[\"path\"]\n            instance.data[\"productType\"] = product_type\n            instance.data[\"productName\"] = product_name\n            instance.data[\"ids\"] = publishable_ids\n            instance.data[\"publish\"] = True\n            instance.data[\"creator_identifier\"] = \"auto_image\"\n            instance.data[\"family\"] = product_type\n            instance.data[\"families\"] = [product_type]\n\n            if auto_creator[\"mark_for_review\"]:\n                instance.data[\"creator_attributes\"] = {\"mark_for_review\": True}\n                instance.data[\"families\"].append(\"review\")\n\n            self.log.info(\"auto image instance: {} \".format(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_image_refresh.html","title":"collect_auto_image_refresh","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_image_refresh.html#client.ayon_photoshop.plugins.publish.collect_auto_image_refresh.CollectAutoImageRefresh","title":"<code>CollectAutoImageRefresh</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Refreshes auto_image instance with currently visible layers..</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_auto_image_refresh.py</code> <pre><code>class CollectAutoImageRefresh(pyblish.api.ContextPlugin):\n    \"\"\"Refreshes auto_image instance with currently visible layers..\n    \"\"\"\n\n    label = \"Collect Auto Image Refresh\"\n    hosts = [\"photoshop\"]\n    order = pyblish.api.CollectorOrder + 0.2\n\n    def process(self, context):\n        for instance in context:\n            creator_identifier = instance.data.get(\"creator_identifier\")\n            if creator_identifier and creator_identifier == \"auto_image\":\n                self.log.debug(\"Auto image instance found, won't create new\")\n                # refresh existing auto image instance with current visible\n                publishable_ids = [layer.id for layer in photoshop.stub().get_layers()  # noqa\n                                   if layer.visible]\n                instance.data[\"ids\"] = publishable_ids\n                return\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_review.html","title":"collect_auto_review","text":"Requires <p>None</p> Provides <p>instance     -&gt; productType (\"review\")</p>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_review.html#client.ayon_photoshop.plugins.publish.collect_auto_review.CollectAutoReview","title":"<code>CollectAutoReview</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Create review instance in non artist based workflow.</p> <p>Called only if PS is triggered in Webpublisher or in tests.</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_auto_review.py</code> <pre><code>class CollectAutoReview(pyblish.api.ContextPlugin):\n    \"\"\"Create review instance in non artist based workflow.\n\n    Called only if PS is triggered in Webpublisher or in tests.\n    \"\"\"\n\n    label = \"Collect Auto Review\"\n    hosts = [\"photoshop\"]\n    order = pyblish.api.CollectorOrder + 0.2\n    targets = [\"automated\"]\n\n    publish = True\n\n    def process(self, context):\n        product_type = \"review\"\n        has_review = False\n        for instance in context:\n            if instance.data[\"productType\"] == product_type:\n                self.log.debug(\"Review instance found, won't create new\")\n                has_review = True\n\n            creator_attributes = instance.data.get(\"creator_attributes\", {})\n            if (creator_attributes.get(\"mark_for_review\") and\n                    \"review\" not in instance.data[\"families\"]):\n                instance.data[\"families\"].append(\"review\")\n\n        if has_review:\n            return\n\n        stub = photoshop.stub()\n        stored_items = stub.get_layers_metadata()\n        for item in stored_items:\n            if item.get(\"creator_identifier\") == product_type:\n                if not item.get(\"active\"):\n                    self.log.debug(\"Review instance disabled\")\n                    return\n\n        auto_creator = context.data[\"project_settings\"].get(\n            \"photoshop\", {}).get(\n            \"create\", {}).get(\n            \"ReviewCreator\", {})\n\n        if not auto_creator or not auto_creator[\"enabled\"]:\n            self.log.debug(\"Review creator disabled, won't create new\")\n            return\n\n        variant = (context.data.get(\"variant\") or\n                   auto_creator[\"default_variant\"])\n\n        project_name = context.data[\"projectName\"]\n        proj_settings = context.data[\"project_settings\"]\n        host_name = context.data[\"hostName\"]\n        folder_entity = context.data[\"folderEntity\"]\n        task_entity = context.data[\"taskEntity\"]\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n\n        product_name = get_product_name(\n            project_name,\n            task_name,\n            task_type,\n            host_name,\n            product_type,\n            variant,\n            project_settings=proj_settings\n        )\n\n        instance = context.create_instance(product_name)\n        instance.data.update({\n            \"label\": product_name,\n            \"name\": product_name,\n            \"productName\": product_name,\n            \"productType\": product_type,\n            \"family\": product_type,\n            \"families\": [product_type],\n            \"representations\": [],\n            \"folderPath\": folder_entity[\"path\"],\n            \"publish\": self.publish\n        })\n\n        self.log.debug(\"auto review created::{}\".format(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_workfile.html","title":"collect_auto_workfile","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_auto_workfile.html#client.ayon_photoshop.plugins.publish.collect_auto_workfile.CollectAutoWorkfile","title":"<code>CollectAutoWorkfile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect current script for publish.</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_auto_workfile.py</code> <pre><code>class CollectAutoWorkfile(pyblish.api.ContextPlugin):\n    \"\"\"Collect current script for publish.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.2\n    label = \"Collect Workfile\"\n    hosts = [\"photoshop\"]\n\n    targets = [\"automated\"]\n\n    def process(self, context):\n        product_type = \"workfile\"\n        file_path = context.data[\"currentFile\"]\n        _, ext = os.path.splitext(file_path)\n        staging_dir = os.path.dirname(file_path)\n        base_name = os.path.basename(file_path)\n        workfile_representation = {\n            \"name\": ext[1:],\n            \"ext\": ext[1:],\n            \"files\": base_name,\n            \"stagingDir\": staging_dir,\n        }\n\n        for instance in context:\n            if instance.data[\"productType\"] == product_type:\n                self.log.debug(\"Workfile instance found, won't create new\")\n                instance.data.update({\n                    \"label\": base_name,\n                    \"name\": base_name,\n                    \"representations\": [],\n                })\n\n                # creating representation\n                _, ext = os.path.splitext(file_path)\n                instance.data[\"representations\"].append(\n                    workfile_representation)\n\n                return\n\n        stub = photoshop.stub()\n        stored_items = stub.get_layers_metadata()\n        for item in stored_items:\n            if item.get(\"creator_identifier\") == product_type:\n                if not item.get(\"active\"):\n                    self.log.debug(\"Workfile instance disabled\")\n                    return\n\n        project_name = context.data[\"projectName\"]\n        proj_settings = context.data[\"project_settings\"]\n        auto_creator = proj_settings.get(\n            \"photoshop\", {}).get(\n            \"create\", {}).get(\n            \"WorkfileCreator\", {})\n\n        if not auto_creator or not auto_creator[\"enabled\"]:\n            self.log.debug(\"Workfile creator disabled, won't create new\")\n            return\n\n        # context.data[\"variant\"] might come only from collect_batch_data\n        variant = (context.data.get(\"variant\") or\n                   auto_creator[\"default_variant\"])\n\n        task_name = context.data[\"task\"]\n        host_name = context.data[\"hostName\"]\n        folder_entity = context.data[\"folderEntity\"]\n        task_entity = context.data[\"taskEntity\"]\n        task_name = task_type = None\n        if task_entity:\n            task_name = task_entity[\"name\"]\n            task_type = task_entity[\"taskType\"]\n\n        product_name = get_product_name(\n            project_name,\n            task_name,\n            task_type,\n            host_name,\n            product_type,\n            variant,\n            project_settings=proj_settings\n        )\n\n        # Create instance\n        instance = context.create_instance(product_name)\n        instance.data.update({\n            \"label\": base_name,\n            \"name\": base_name,\n            \"productName\": product_name,\n            \"productType\": product_type,\n            \"family\": product_type,\n            \"families\": [product_type],\n            \"representations\": [],\n            \"folderPath\": folder_entity[\"path\"]\n        })\n\n        # creating representation\n        instance.data[\"representations\"].append(workfile_representation)\n\n        self.log.debug(\"auto workfile review created:{}\".format(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_batch_data.html","title":"collect_batch_data","text":"<p>Parses batch context from json and continues in publish process.</p> Provides <p>context -&gt; Loaded batch file.     - folderPath     - task  (task name)     - taskType     - project_name     - variant</p> <p>Code is practically copy of <code>openype/hosts/webpublish/collect_batch_data</code> as webpublisher should be eventually ejected as an addon, eg. mentioned plugin shouldn't be pushed into general publish plugins.</p>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_batch_data.html#client.ayon_photoshop.plugins.publish.collect_batch_data.CollectBatchData","title":"<code>CollectBatchData</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect batch data from json stored in 'AYON_PUBLISH_DATA' env dir.</p> <p>The directory must contain 'manifest.json' file where batch data should be stored.</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_batch_data.py</code> <pre><code>class CollectBatchData(pyblish.api.ContextPlugin):\n    \"\"\"Collect batch data from json stored in 'AYON_PUBLISH_DATA' env dir.\n\n    The directory must contain 'manifest.json' file where batch data should be\n    stored.\n    \"\"\"\n    # must be really early, context values are only in json file\n    order = pyblish.api.CollectorOrder - 0.495\n    label = \"Collect batch data\"\n    hosts = [\"photoshop\"]\n    targets = [\"webpublish\"]\n\n    def process(self, context):\n        self.log.info(\"CollectBatchData\")\n        batch_dir = (\n            os.environ.get(\"AYON_PUBLISH_DATA\")\n            or os.environ.get(\"OPENPYPE_PUBLISH_DATA\")\n        )\n        if is_in_tests():\n            self.log.debug(\"Automatic testing, no batch data, skipping\")\n            return\n\n        assert batch_dir, (\n            \"Missing `AYON_PUBLISH_DATA`\")\n\n        assert os.path.exists(batch_dir), \\\n            \"Folder {} doesn't exist\".format(batch_dir)\n\n        project_name = os.environ.get(\"AYON_PROJECT_NAME\")\n        if project_name is None:\n            raise AssertionError(\n                \"Environment `AYON_PROJECT_NAME` was not found.\"\n                \"Could not set project `root` which may cause issues.\"\n            )\n\n        batch_data = parse_json(os.path.join(batch_dir, \"manifest.json\"))\n\n        context.data[\"batchDir\"] = batch_dir\n        context.data[\"batchData\"] = batch_data\n\n        folder_path, task_name, task_type = get_batch_context_info(\n            batch_data[\"context\"]\n        )\n\n        os.environ[\"AYON_FOLDER_PATH\"] = folder_path\n        os.environ[\"AYON_TASK_NAME\"] = task_name\n\n        context.data[\"folderPath\"] = folder_path\n        context.data[\"task\"] = task_name\n        context.data[\"taskType\"] = task_type\n        context.data[\"project_name\"] = project_name\n        context.data[\"variant\"] = batch_data[\"variant\"]\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_color_coded_instances.html","title":"collect_color_coded_instances","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_color_coded_instances.html#client.ayon_photoshop.plugins.publish.collect_color_coded_instances.CollectColorCodedInstances","title":"<code>CollectColorCodedInstances</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Creates instances for layers marked by configurable color.</p> <p>Used in remote publishing when artists marks publishable layers by color- coding. Top level layers (group) must be marked by specific color to be published as an instance of 'image' product type.</p> <p>Can add group for all publishable layers to allow creation of flattened image. (Cannot contain special background layer as it cannot be grouped!)</p> <p>Based on value <code>create_flatten_image</code> from Settings: - \"yes\": create flattened 'image' product of all publishable layers + create     'image' product per publishable layer - \"only\": create ONLY flattened 'image' product of all publishable layers - \"no\": do not create flattened 'image' product at all,     only separate products per marked layer.</p> Identifier <p>id (str): \"ayon.create.instance\"</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_color_coded_instances.py</code> <pre><code>class CollectColorCodedInstances(pyblish.api.ContextPlugin):\n    \"\"\"Creates instances for layers marked by configurable color.\n\n    Used in remote publishing when artists marks publishable layers by color-\n    coding. Top level layers (group) must be marked by specific color to be\n    published as an instance of 'image' product type.\n\n    Can add group for all publishable layers to allow creation of flattened\n    image. (Cannot contain special background layer as it cannot be grouped!)\n\n    Based on value `create_flatten_image` from Settings:\n    - \"yes\": create flattened 'image' product of all publishable layers + create\n        'image' product per publishable layer\n    - \"only\": create ONLY flattened 'image' product of all publishable layers\n    - \"no\": do not create flattened 'image' product at all,\n        only separate products per marked layer.\n\n    Identifier:\n        id (str): \"ayon.create.instance\"\n    \"\"\"\n\n    label = \"Collect Color-coded Instances\"\n    order = pyblish.api.CollectorOrder\n    hosts = [\"photoshop\"]\n    targets = [\"automated\"]\n    settings_category = \"photoshop\"\n\n    # configurable by Settings\n    color_code_mapping = []\n    create_flatten_image = \"no\"\n    flatten_product_name_template = \"\"\n\n    def process(self, context):\n        self.log.info(\"CollectColorCodedInstances\")\n        batch_dir = (\n            os.environ.get(\"AYON_PUBLISH_DATA\")\n            or os.environ.get(\"OPENPYPE_PUBLISH_DATA\")\n        )\n        if (\n            is_in_tests()\n            and (\n                not batch_dir or not os.path.exists(batch_dir)\n            )\n        ):\n            self.log.debug(\"Automatic testing, no batch data, skipping\")\n            return\n\n        existing_product_names = self._get_existing_product_names(context)\n\n        # from CollectBatchData\n        folder_path = context.data[\"folderPath\"]\n        task_name = context.data[\"task\"]\n        variant = context.data[\"variant\"]\n        project_name = context.data[\"projectEntity\"][\"name\"]\n\n        naming_conventions = get_project_settings(project_name).get(\n            \"photoshop\", {}).get(\n            \"publish\", {}).get(\n            \"ValidateNaming\", {})\n\n        stub = photoshop.stub()\n        layers = stub.get_layers()\n\n        publishable_layers = []\n        created_instances = []\n        product_type_from_settings = None\n        for layer in layers:\n            self.log.debug(\"Layer:: {}\".format(layer))\n            if layer.parents:\n                self.log.debug(\"!!! Not a top layer, skip\")\n                continue\n\n            if not layer.visible:\n                self.log.debug(\"Not visible, skip\")\n                continue\n\n            resolved_product_type, resolved_product_template = (\n                self._resolve_mapping(layer)\n            )\n\n            if not resolved_product_template or not resolved_product_type:\n                self.log.debug(\"!!! Not found product type or template, skip\")\n                continue\n\n            if not product_type_from_settings:\n                product_type_from_settings = resolved_product_type\n\n            fill_pairs = {\n                \"variant\": variant,\n                \"family\": resolved_product_type,\n                \"product\": {\"type\": resolved_product_type},\n                \"task\": task_name,\n                \"layer\": layer.clean_name\n            }\n\n            product_name = resolved_product_template.format(\n                **prepare_template_data(fill_pairs))\n\n            product_name = self._clean_product_name(\n                stub, naming_conventions, product_name, layer\n            )\n\n            if product_name in existing_product_names:\n                self.log.info((\n                    \"Product {} already created, skipping.\"\n                ).format(product_name))\n                continue\n\n            if self.create_flatten_image != \"flatten_only\":\n                instance = self._create_instance(\n                    context,\n                    layer,\n                    resolved_product_type,\n                    folder_path,\n                    product_name,\n                    task_name\n                )\n                created_instances.append(instance)\n\n            existing_product_names.append(product_name)\n            publishable_layers.append(layer)\n\n        if self.create_flatten_image != \"no\" and publishable_layers:\n            self.log.debug(\"create_flatten_image\")\n            if not self.flatten_product_name_template:\n                self.log.warning(\"No template for flatten image\")\n                return\n\n            fill_pairs.pop(\"layer\")\n            product_name = self.flatten_product_name_template.format(\n                **prepare_template_data(fill_pairs))\n\n            first_layer = publishable_layers[0]  # dummy layer\n            first_layer.name = product_name\n            product_type = product_type_from_settings  # inherit product type\n            instance = self._create_instance(\n                context,\n                first_layer,\n                product_type,\n                folder_path,\n                product_name,\n                task_name\n            )\n            instance.data[\"ids\"] = [layer.id for layer in publishable_layers]\n            created_instances.append(instance)\n\n        for instance in created_instances:\n            # Produce diagnostic message for any graphical\n            # user interface interested in visualising it.\n            self.log.info(\"Found: \\\"%s\\\" \" % instance.data[\"name\"])\n            self.log.info(\"instance: {} \".format(instance.data))\n\n    def _get_existing_product_names(self, context):\n        \"\"\"Collect manually created instances from workfile.\n\n        Shouldn't be any as Webpublisher bypass publishing via Openpype, but\n        might be some if workfile published through OP is reused.\n        \"\"\"\n        existing_product_names = []\n        for instance in context:\n            if instance.data.get(\"publish\") is not False:\n                existing_product_names.append(instance.data.get(\"productName\"))\n\n        return existing_product_names\n\n    def _create_instance(\n        self,\n        context,\n        layer,\n        product_type,\n        folder_path,\n        product_name,\n        task_name\n    ):\n        instance = context.create_instance(layer.name)\n        instance.data[\"publish\"] = True\n        instance.data[\"productType\"] = product_type\n        instance.data[\"productName\"] = product_name\n        instance.data[\"folderPath\"] = folder_path\n        instance.data[\"task\"] = task_name\n        instance.data[\"layer\"] = layer\n        instance.data[\"family\"] = product_type\n        instance.data[\"families\"] = [product_type]\n\n        return instance\n\n    def _resolve_mapping(self, layer):\n        \"\"\"Matches 'layer' color code and name to mapping.\n\n            If both color code AND name regex is configured, BOTH must be valid\n            If layer matches to multiple mappings, only first is used!\n        \"\"\"\n        product_type_list = []\n        product_name_list = []\n        for mapping in self.color_code_mapping:\n            if (\n                mapping[\"color_code\"]\n                and layer.color_code not in mapping[\"color_code\"]\n            ):\n                continue\n\n            if (\n                mapping[\"layer_name_regex\"]\n                and not any(\n                    re.search(pattern, layer.name)\n                    for pattern in mapping[\"layer_name_regex\"]\n                )\n            ):\n                continue\n\n            product_type_list.append(mapping[\"product_type\"])\n            product_name_list.append(mapping[\"product_name_template\"])\n\n        if len(product_name_list) &gt; 1:\n            self.log.warning(\n                \"Multiple mappings found for '{}'\".format(layer.name)\n            )\n            self.log.warning(\"Only first product name template used!\")\n            product_name_list[:] = product_name_list[0]\n\n        if len(product_type_list) &gt; 1:\n            self.log.warning(\n                \"Multiple mappings found for '{}'\".format(layer.name)\n            )\n            self.log.warning(\"Only first product type used!\")\n            product_type_list[:] = product_type_list[0]\n\n        resolved_product_template = None\n        if product_name_list:\n            resolved_product_template = product_name_list.pop()\n\n        product_type = None\n        if product_type_list:\n            product_type = product_type_list.pop()\n\n        self.log.debug(\"resolved_product_type {}\".format(product_type))\n        self.log.debug(\"resolved_product_template {}\".format(\n            resolved_product_template))\n        return product_type, resolved_product_template\n\n    def _clean_product_name(\n        self, stub, naming_conventions, product_name, layer\n    ):\n        \"\"\"Cleans invalid characters from product name and layer name.\"\"\"\n        if re.search(naming_conventions[\"invalid_chars\"], product_name):\n            product_name = re.sub(\n                naming_conventions[\"invalid_chars\"],\n                naming_conventions[\"replace_char\"],\n                product_name\n            )\n            layer_name = re.sub(\n                naming_conventions[\"invalid_chars\"],\n                naming_conventions[\"replace_char\"],\n                layer.clean_name\n            )\n            layer.name = layer_name\n            stub.rename_layer(layer.id, layer_name)\n\n        return product_name\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_current_file.html#client.ayon_photoshop.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Current File\"\n    hosts = [\"photoshop\"]\n\n    def process(self, context):\n        context.data[\"currentFile\"] = os.path.normpath(\n            photoshop.stub().get_active_document_full_name()\n        ).replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_extension_version.html","title":"collect_extension_version","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_extension_version.html#client.ayon_photoshop.plugins.publish.collect_extension_version.CollectExtensionVersion","title":"<code>CollectExtensionVersion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Pulls and compares version of installed extension.</p> <p>It is recommended to use same extension as in provided Openpype code.</p> <p>Please use Anastasiy\u2019s Extension Manager or ZXPInstaller to update extension in case of an error.</p> <p>You can locate extension.zxp in your installed Openpype code in <code>repos/avalon-core/avalon/photoshop</code></p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_extension_version.py</code> <pre><code>class CollectExtensionVersion(pyblish.api.ContextPlugin):\n    \"\"\" Pulls and compares version of installed extension.\n\n        It is recommended to use same extension as in provided Openpype code.\n\n        Please use Anastasiy\u2019s Extension Manager or ZXPInstaller to update\n        extension in case of an error.\n\n        You can locate extension.zxp in your installed Openpype code in\n        `repos/avalon-core/avalon/photoshop`\n    \"\"\"\n    # This technically should be a validator, but other collectors might be\n    # impacted with usage of obsolete extension, so collector that runs first\n    # was chosen\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Collect extension version\"\n    hosts = [\"photoshop\"]\n\n    optional = True\n    active = True\n\n    def process(self, context):\n        installed_version = photoshop.stub().get_extension_version()\n\n        if not installed_version:\n            raise ValueError(\"Unknown version, probably old extension\")\n\n        manifest_url = os.path.join(os.path.dirname(photoshop.__file__),\n                                    \"extension\", \"CSXS\", \"manifest.xml\")\n\n        if not os.path.exists(manifest_url):\n            self.log.debug(\"Unable to locate extension manifest, not checking\")\n            return\n\n        expected_version = None\n        with open(manifest_url) as fp:\n            content = fp.read()\n\n            found = re.findall(r'(ExtensionBundleVersion=\")([0-9\\.]+)(\")',\n                               content)\n            if found:\n                expected_version = found[0][1]\n\n        if expected_version != installed_version:\n            msg = \"Expected version '{}' found '{}'\\n\".format(\n                expected_version, installed_version)\n            msg += \"Please update your installed extension, it might not work \"\n            msg += \"properly.\"\n\n            raise ValueError(msg)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_image.html","title":"collect_image","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_image.html#client.ayon_photoshop.plugins.publish.collect_image.CollectImage","title":"<code>CollectImage</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect layer metadata into a instance.</p> <p>Used later in validation</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_image.py</code> <pre><code>class CollectImage(pyblish.api.InstancePlugin):\n    \"\"\"Collect layer metadata into a instance.\n\n    Used later in validation\n    \"\"\"\n    order = pyblish.api.CollectorOrder + 0.200\n    label = 'Collect Image'\n\n    hosts = [\"photoshop\"]\n    families = [\"image\"]\n\n    def process(self, instance):\n        if instance.data.get(\"members\"):\n            layer = api.stub().get_layer(instance.data[\"members\"][0])\n            instance.data[\"layer\"] = layer\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_published_version.html","title":"collect_published_version","text":"<p>Collects published version of workfile and increments it.</p> <p>For synchronization of published image and workfile version it is required to store workfile version from workfile file name in context.data[\"version\"]. In remote publishing this name is unreliable (artist might not follow naming convention etc.), last published workfile version for particular workfile product is used instead.</p> <p>This plugin runs only in remote publishing (eg. Webpublisher).</p> Requires <p>context.data[\"folderEntity\"]</p> Provides <p>context[\"version\"] - incremented latest published workfile version</p>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_published_version.html#client.ayon_photoshop.plugins.publish.collect_published_version.CollectPublishedVersion","title":"<code>CollectPublishedVersion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collects published version of workfile and increments it.</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_published_version.py</code> <pre><code>class CollectPublishedVersion(pyblish.api.ContextPlugin):\n    \"\"\"Collects published version of workfile and increments it.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.190\n    label = \"Collect published version\"\n    hosts = [\"photoshop\"]\n    targets = [\"automated\"]\n\n    def process(self, context):\n        workfile_product_name = None\n        for instance in context:\n            if instance.data[\"productType\"] == \"workfile\":\n                workfile_product_name = instance.data[\"productName\"]\n                break\n\n        if not workfile_product_name:\n            self.log.warning(\"No workfile instance found, \"\n                             \"synchronization of version will not work.\")\n            return\n\n        project_name = context.data[\"projectName\"]\n        folder_id = context.data[\"folderEntity\"][\"id\"]\n\n        version_entity = ayon_api.get_last_version_by_product_name(\n            project_name, workfile_product_name, folder_id\n        )\n\n        if version_entity:\n            version_int = int(version_entity[\"version\"]) + 1\n        else:\n            version_int = get_versioning_start(\n                project_name,\n                \"photoshop\",\n                task_name=context.data[\"task\"],\n                task_type=context.data[\"taskType\"],\n                project_settings=context.data[\"project_settings\"]\n            )\n\n        self.log.debug(f\"Setting {version_int} to context.\")\n        context.data[\"version\"] = version_int\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_review.html","title":"collect_review","text":"Requires <p>None</p> Provides <p>instance     -&gt; family (\"review\")</p>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_review.html#client.ayon_photoshop.plugins.publish.collect_review.CollectReview","title":"<code>CollectReview</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Adds review to families for instances marked to be reviewable.</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_review.py</code> <pre><code>class CollectReview(pyblish.api.ContextPlugin):\n    \"\"\"Adds review to families for instances marked to be reviewable.\n    \"\"\"\n\n    label = \"Collect Review\"\n    hosts = [\"photoshop\"]\n    order = pyblish.api.CollectorOrder + 0.1\n    settings_category = \"photoshop\"\n\n    def process(self, context):\n        for instance in context:\n            creator_attributes = instance.data[\"creator_attributes\"]\n            if (creator_attributes.get(\"mark_for_review\") and\n                    \"review\" not in instance.data[\"families\"]):\n                instance.data[\"families\"].append(\"review\")\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_version.html","title":"collect_version","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_version.html#client.ayon_photoshop.plugins.publish.collect_version.CollectVersion","title":"<code>CollectVersion</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect version for publishable instances.</p> Used to synchronize version from workfile to all publishable instances <ul> <li>image (manually created or color coded)</li> <li>review</li> <li>workfile</li> </ul> <p>Dev comment: Explicit collector created to control this from single place and not from 3 different.</p> <p>Workfile set here explicitly as version might to be forced from latest + 1 because of Webpublisher. (This plugin must run after CollectPublishedVersion!)</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_version.py</code> <pre><code>class CollectVersion(pyblish.api.InstancePlugin):\n    \"\"\"Collect version for publishable instances.\n\n    Used to synchronize version from workfile to all publishable instances:\n        - image (manually created or color coded)\n        - review\n        - workfile\n\n    Dev comment:\n    Explicit collector created to control this from single place and not from\n    3 different.\n\n    Workfile set here explicitly as version might to be forced from latest + 1\n    because of Webpublisher.\n    (This plugin must run after CollectPublishedVersion!)\n    \"\"\"\n    order = pyblish.api.CollectorOrder + 0.200\n    label = 'Collect Version'\n\n    hosts = [\"photoshop\"]\n    families = [\"image\", \"review\", \"workfile\"]\n    settings_category = \"photoshop\"\n\n    def process(self, instance):\n        workfile_version = instance.context.data[\"version\"]\n        self.log.debug(f\"Applying version {workfile_version}\")\n        instance.data[\"version\"] = workfile_version\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/collect_workfile.html#client.ayon_photoshop.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect current script for publish.</p> Source code in <code>client/ayon_photoshop/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(pyblish.api.ContextPlugin):\n    \"\"\"Collect current script for publish.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.1\n    label = \"Collect Workfile\"\n    hosts = [\"photoshop\"]\n\n    default_variant = \"Main\"\n\n    def process(self, context):\n        for instance in context:\n            if instance.data[\"productType\"] == \"workfile\":\n                file_path = context.data[\"currentFile\"]\n                _, ext = os.path.splitext(file_path)\n                staging_dir = os.path.dirname(file_path)\n                base_name = os.path.basename(file_path)\n\n                # creating representation\n                _, ext = os.path.splitext(file_path)\n                instance.data[\"representations\"].append({\n                    \"name\": ext[1:],\n                    \"ext\": ext[1:],\n                    \"files\": base_name,\n                    \"stagingDir\": staging_dir,\n                })\n                return\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/extract_image.html","title":"extract_image","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/extract_image.html#client.ayon_photoshop.plugins.publish.extract_image.ExtractImage","title":"<code>ExtractImage</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Extract all layers (groups) marked for publish.</p> <p>Usually publishable instance is created as a wrapper of layer(s). For each publishable instance so many images as there is 'formats' is created.</p> <p>Logic tries to hide/unhide layers minimum times.</p> <p>Called once for all publishable instances.</p> Source code in <code>client/ayon_photoshop/plugins/publish/extract_image.py</code> <pre><code>class ExtractImage(pyblish.api.ContextPlugin):\n    \"\"\"Extract all layers (groups) marked for publish.\n\n    Usually publishable instance is created as a wrapper of layer(s). For each\n    publishable instance so many images as there is 'formats' is created.\n\n    Logic tries to hide/unhide layers minimum times.\n\n    Called once for all publishable instances.\n    \"\"\"\n\n    order = publish.Extractor.order - 0.48\n    label = \"Extract Image\"\n    hosts = [\"photoshop\"]\n\n    families = [\"image\", \"background\"]\n    formats = [\"png\", \"jpg\"]\n    settings_category = \"photoshop\"\n\n    def process(self, context):\n        stub = photoshop.stub()\n        hidden_layer_ids = set()\n\n        all_layers = stub.get_layers()\n        for layer in all_layers:\n            if not layer.visible:\n                hidden_layer_ids.add(layer.id)\n        stub.hide_all_others_layers_ids([], layers=all_layers)\n\n        with photoshop.maintained_selection():\n            with photoshop.maintained_visibility(layers=all_layers):\n                for instance in context:\n                    if instance.data[\"productType\"] not in self.families:\n                        continue\n\n                    staging_dir = self.staging_dir(instance)\n                    self.log.info(\"Outputting image to {}\".format(staging_dir))\n\n                    # Perform extraction\n                    files = {}\n                    ids = set()\n                    # real layers and groups\n                    members = instance.data(\"members\")\n                    if members:\n                        ids.update(set([int(member) for member in members]))\n                    # virtual groups collected by color coding or auto_image\n                    add_ids = instance.data.pop(\"ids\", None)\n                    if add_ids:\n                        ids.update(set(add_ids))\n                    extract_ids = set([ll.id for ll in stub.\n                                      get_layers_in_layers_ids(ids, all_layers)\n                                       if ll.id not in hidden_layer_ids])\n\n                    for extracted_id in extract_ids:\n                        stub.set_visible(extracted_id, True)\n\n                    file_basename = os.path.splitext(\n                        stub.get_active_document_name()\n                    )[0]\n                    for extension in self.formats:\n                        _filename = \"{}.{}\".format(file_basename,\n                                                   extension)\n                        files[extension] = _filename\n\n                        full_filename = os.path.join(staging_dir,\n                                                     _filename)\n                        stub.saveAs(full_filename, extension, True)\n                        self.log.info(f\"Extracted: {extension}\")\n\n                    representations = []\n                    for extension, filename in files.items():\n                        representations.append({\n                            \"name\": extension,\n                            \"ext\": extension,\n                            \"files\": filename,\n                            \"stagingDir\": staging_dir\n                        })\n                    instance.data[\"representations\"] = representations\n                    instance.data[\"stagingDir\"] = staging_dir\n\n                    self.log.info(f\"Extracted {instance} to {staging_dir}\")\n\n                    for extracted_id in extract_ids:\n                        stub.set_visible(extracted_id, False)\n\n    def staging_dir(self, instance):\n        \"\"\"Provide a temporary directory in which to store extracted files\n\n        Upon calling this method the staging directory is stored inside\n        the instance.data['stagingDir']\n        \"\"\"\n\n        from ayon_core.pipeline.publish import get_instance_staging_dir\n\n        return get_instance_staging_dir(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/extract_image.html#client.ayon_photoshop.plugins.publish.extract_image.ExtractImage.staging_dir","title":"<code>staging_dir(instance)</code>","text":"<p>Provide a temporary directory in which to store extracted files</p> <p>Upon calling this method the staging directory is stored inside the instance.data['stagingDir']</p> Source code in <code>client/ayon_photoshop/plugins/publish/extract_image.py</code> <pre><code>def staging_dir(self, instance):\n    \"\"\"Provide a temporary directory in which to store extracted files\n\n    Upon calling this method the staging directory is stored inside\n    the instance.data['stagingDir']\n    \"\"\"\n\n    from ayon_core.pipeline.publish import get_instance_staging_dir\n\n    return get_instance_staging_dir(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/extract_review.html","title":"extract_review","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/extract_review.html#client.ayon_photoshop.plugins.publish.extract_review.ExtractReview","title":"<code>ExtractReview</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Produce a flattened or sequence image files from all 'image' instances.</p> <p>If no 'image' instance is created, it produces flattened image from all visible layers.</p> <p>It creates review, thumbnail and mov representations.</p> <p>'review' family could be used in other steps as a reference, as it contains flattened image by default. (Eg. artist could load this review as a single item and see full image. In most cases 'image' product type is separated by layers to better usage in animation or comp.)</p> Source code in <code>client/ayon_photoshop/plugins/publish/extract_review.py</code> <pre><code>class ExtractReview(publish.Extractor):\n    \"\"\"\n        Produce a flattened or sequence image files from all 'image' instances.\n\n        If no 'image' instance is created, it produces flattened image from\n        all visible layers.\n\n        It creates review, thumbnail and mov representations.\n\n        'review' family could be used in other steps as a reference, as it\n        contains flattened image by default. (Eg. artist could load this\n        review as a single item and see full image. In most cases 'image'\n        product type is separated by layers to better usage in animation\n        or comp.)\n    \"\"\"\n\n    label = \"Extract Review\"\n    hosts = [\"photoshop\"]\n    families = [\"review\"]\n    settings_category = \"photoshop\"\n\n    # Extract Options\n    jpg_options = None\n    mov_options = None\n    make_image_sequence = None\n    max_downscale_size = 8192\n\n    def process(self, instance):\n        staging_dir = self.staging_dir(instance)\n        self.log.info(\"Outputting image to {}\".format(staging_dir))\n\n        fps = instance.data.get(\"fps\", 25)\n        stub = photoshop.stub()\n        self.output_seq_filename = os.path.splitext(\n            stub.get_active_document_name())[0] + \".%04d.jpg\"\n\n        layers = self._get_layers_from_image_instances(instance)\n        self.log.info(\"Layers image instance found: {}\".format(layers))\n\n        repre_name = \"jpg\"\n        repre_skeleton = {\n            \"name\": repre_name,\n            \"ext\": \"jpg\",\n            \"stagingDir\": staging_dir,\n            \"tags\": self.jpg_options['tags'],\n        }\n\n        if instance.data[\"productType\"] != \"review\":\n            self.log.debug(\n                \"Existing extracted file from image product type used.\"\n            )\n            # enable creation of review, without this jpg review would clash\n            # with jpg of the image product type\n            output_name = repre_name\n            repre_name = \"{}_{}\".format(repre_name, output_name)\n            repre_skeleton.update({\"name\": repre_name,\n                                   \"outputName\": output_name})\n\n            img_file = self.output_seq_filename % 0\n            self._prepare_file_for_image_product_type(\n                img_file, instance, staging_dir\n            )\n            repre_skeleton.update({\n                \"files\": img_file,\n            })\n            processed_img_names = [img_file]\n        elif self.make_image_sequence and len(layers) &gt; 1:\n            self.log.debug(\"Extract layers to image sequence.\")\n            img_list = self._save_sequence_images(staging_dir, layers)\n\n            repre_skeleton.update({\n                \"frameStart\": 0,\n                \"frameEnd\": len(img_list),\n                \"fps\": fps,\n                \"files\": img_list,\n            })\n            processed_img_names = img_list\n        else:\n            self.log.debug(\"Extract layers to flatten image.\")\n            img_file = self._save_flatten_image(staging_dir, layers)\n\n            repre_skeleton.update({\n                \"files\": img_file,\n            })\n            processed_img_names = [img_file]\n\n        instance.data[\"representations\"].append(repre_skeleton)\n\n        ffmpeg_args = get_ffmpeg_tool_args(\"ffmpeg\")\n\n        instance.data[\"stagingDir\"] = staging_dir\n\n        source_files_pattern = os.path.join(staging_dir,\n                                            self.output_seq_filename)\n        source_files_pattern = self._check_and_resize(processed_img_names,\n                                                      source_files_pattern,\n                                                      staging_dir)\n        self._generate_thumbnail(\n            list(ffmpeg_args),\n            instance,\n            source_files_pattern,\n            staging_dir)\n\n        no_of_frames = len(processed_img_names)\n        if no_of_frames &gt; 1:\n            self._generate_mov(\n                list(ffmpeg_args),\n                instance,\n                fps,\n                no_of_frames,\n                source_files_pattern,\n                staging_dir)\n\n        self.log.info(f\"Extracted {instance} to {staging_dir}\")\n\n    def _prepare_file_for_image_product_type(\n        self, img_file, instance, staging_dir\n    ):\n        \"\"\"Converts existing file for image product type to .jpg\n\n        Image instance could have its own separate review (instance per layer\n        for example). This uses extracted file instead of extracting again.\n        Args:\n            img_file (str): name of output file (with 0000 value for ffmpeg\n                later)\n            instance:\n            staging_dir (str): temporary folder where extracted file is located\n        \"\"\"\n        repre_file = instance.data[\"representations\"][0]\n        source_file_path = os.path.join(repre_file[\"stagingDir\"],\n                                        repre_file[\"files\"])\n        if not os.path.exists(source_file_path):\n            raise RuntimeError(f\"{source_file_path} doesn't exist for \"\n                               \"review to create from\")\n        _, ext = os.path.splitext(repre_file[\"files\"])\n        if ext != \".jpg\":\n            im = Image.open(source_file_path)\n            if (im.mode in ('RGBA', 'LA') or (\n                    im.mode == 'P' and 'transparency' in im.info)):\n                # without this it produces messy low quality jpg\n                rgb_im = Image.new(\"RGBA\", (im.width, im.height), \"#ffffff\")\n                rgb_im.alpha_composite(im)\n                rgb_im.convert(\"RGB\").save(os.path.join(staging_dir, img_file))\n            else:\n                im.save(os.path.join(staging_dir, img_file))\n        else:\n            # handles already .jpg\n            shutil.copy(source_file_path,\n                        os.path.join(staging_dir, img_file))\n\n    def _generate_mov(self, ffmpeg_path, instance, fps, no_of_frames,\n                      source_files_pattern, staging_dir):\n        \"\"\"Generates .mov to upload to Ftrack.\n\n        Args:\n            ffmpeg_path (str): path to ffmpeg\n            instance (Pyblish Instance)\n            fps (str)\n            no_of_frames (int):\n            source_files_pattern (str): name of source file\n            staging_dir (str): temporary location to store thumbnail\n        Updates:\n            instance - adds representation portion\n        \"\"\"\n        # Generate mov.\n        mov_path = os.path.join(staging_dir, \"review.mov\")\n        self.log.info(f\"Generate mov review: {mov_path}\")\n        args = ffmpeg_path + [\n            \"-y\",\n            \"-i\", source_files_pattern,\n            \"-vf\", \"pad=ceil(iw/2)*2:ceil(ih/2)*2\",\n            \"-vframes\", str(no_of_frames),\n            mov_path\n        ]\n        self.log.debug(\"mov args:: {}\".format(args))\n        _output = run_subprocess(args)\n        instance.data[\"representations\"].append({\n            \"name\": \"mov\",\n            \"ext\": \"mov\",\n            \"files\": os.path.basename(mov_path),\n            \"stagingDir\": staging_dir,\n            \"frameStart\": 1,\n            \"frameEnd\": no_of_frames,\n            \"fps\": fps,\n            \"tags\": self.mov_options['tags']\n        })\n\n    def _generate_thumbnail(\n        self, ffmpeg_args, instance, source_files_pattern, staging_dir\n    ):\n        \"\"\"Generates scaled down thumbnail and adds it as representation.\n\n        Args:\n            ffmpeg_path (str): path to ffmpeg\n            instance (Pyblish Instance)\n            source_files_pattern (str): name of source file\n            staging_dir (str): temporary location to store thumbnail\n        Updates:\n            instance - adds representation portion\n        \"\"\"\n        # Generate thumbnail\n        thumbnail_path = os.path.join(staging_dir, \"thumbnail.jpg\")\n        self.log.info(f\"Generate thumbnail {thumbnail_path}\")\n        args = ffmpeg_args + [\n            \"-y\",\n            \"-i\", source_files_pattern,\n            \"-vf\", \"scale=300:-1\",\n            \"-vframes\", \"1\",\n            thumbnail_path\n        ]\n        self.log.debug(\"thumbnail args:: {}\".format(args))\n        _output = run_subprocess(args)\n        instance.data[\"representations\"].append({\n            \"name\": \"thumbnail\",\n            \"ext\": \"jpg\",\n            \"outputName\": \"thumb\",\n            \"files\": os.path.basename(thumbnail_path),\n            \"stagingDir\": staging_dir,\n            \"tags\": [\"thumbnail\", \"delete\"]\n        })\n        instance.data[\"thumbnailPath\"] = thumbnail_path\n\n    def _check_and_resize(self, processed_img_names, source_files_pattern,\n                          staging_dir):\n        \"\"\"Check if saved image could be used in ffmpeg.\n\n        Ffmpeg has max size 16384x16384. Saved image(s) must be resized to be\n        used as a source for thumbnail or review mov.\n        \"\"\"\n        Image.MAX_IMAGE_PIXELS = None\n        first_url = os.path.join(staging_dir, processed_img_names[0])\n        with Image.open(first_url) as im:\n            width, height = im.size\n\n        if width &gt; self.max_downscale_size or height &gt; self.max_downscale_size:\n            resized_dir = os.path.join(staging_dir, \"resized\")\n            os.mkdir(resized_dir)\n            source_files_pattern = os.path.join(resized_dir,\n                                                self.output_seq_filename)\n            for file_name in processed_img_names:\n                source_url = os.path.join(staging_dir, file_name)\n                with Image.open(source_url) as res_img:\n                    # 'thumbnail' automatically keeps aspect ratio\n                    res_img.thumbnail((self.max_downscale_size,\n                                       self.max_downscale_size),\n                                      Image.ANTIALIAS)\n                    res_img.save(os.path.join(resized_dir, file_name))\n\n        return source_files_pattern\n\n    def _get_layers_from_image_instances(self, instance):\n        \"\"\"Collect all layers from 'instance'.\n\n        Returns:\n            (list) of PSItem\n        \"\"\"\n        layers = []\n        # creating review for existing 'image' instance\n        if (\n            instance.data[\"productType\"] == \"image\"\n            and instance.data.get(\"layer\")\n        ):\n            layers.append(instance.data[\"layer\"])\n            return layers\n\n        for image_instance in instance.context:\n            if image_instance.data[\"productType\"] != \"image\":\n                continue\n            if not image_instance.data.get(\"layer\"):\n                # dummy instance for flatten image\n                continue\n            layers.append(image_instance.data.get(\"layer\"))\n\n        return sorted(layers)\n\n    def _save_flatten_image(self, staging_dir, layers):\n        \"\"\"Creates flat image from 'layers' into 'staging_dir'.\n\n        Returns:\n            (str): path to new image\n        \"\"\"\n        img_filename = self.output_seq_filename % 0\n        output_image_path = os.path.join(staging_dir, img_filename)\n        stub = photoshop.stub()\n\n        with photoshop.maintained_visibility():\n            self.log.info(\"Extracting {}\".format(layers))\n            if layers:\n                stub.hide_all_others_layers(layers)\n\n            stub.saveAs(output_image_path, 'jpg', True)\n\n        return img_filename\n\n    def _save_sequence_images(self, staging_dir, layers):\n        \"\"\"Creates separate flat images from 'layers' into 'staging_dir'.\n\n        Used as source for multi frames .mov to review at once.\n        Returns:\n            (list): paths to new images\n        \"\"\"\n        stub = photoshop.stub()\n\n        list_img_filename = []\n        with photoshop.maintained_visibility():\n            for i, layer in enumerate(layers):\n                self.log.info(\"Extracting {}\".format(layer))\n\n                img_filename = self.output_seq_filename % i\n                output_image_path = os.path.join(staging_dir, img_filename)\n                list_img_filename.append(img_filename)\n\n                with photoshop.maintained_visibility():\n                    stub.hide_all_others_layers([layer])\n                    stub.saveAs(output_image_path, 'jpg', True)\n\n        return list_img_filename\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/extract_save_scene.html","title":"extract_save_scene","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/extract_save_scene.html#client.ayon_photoshop.plugins.publish.extract_save_scene.ExtractSaveScene","title":"<code>ExtractSaveScene</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Save scene before extraction.</p> Source code in <code>client/ayon_photoshop/plugins/publish/extract_save_scene.py</code> <pre><code>class ExtractSaveScene(publish.Extractor):\n    \"\"\"Save scene before extraction.\"\"\"\n\n    order = publish.Extractor.order - 0.49\n    label = \"Extract Save Scene\"\n    hosts = [\"photoshop\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        photoshop.stub().save()\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/increment_workfile.html","title":"increment_workfile","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/increment_workfile.html#client.ayon_photoshop.plugins.publish.increment_workfile.IncrementWorkfile","title":"<code>IncrementWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Increment the current workfile.</p> <p>Saves the current scene with an increased version number.</p> Source code in <code>client/ayon_photoshop/plugins/publish/increment_workfile.py</code> <pre><code>class IncrementWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Increment the current workfile.\n\n    Saves the current scene with an increased version number.\n    \"\"\"\n\n    label = \"Increment Workfile\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    hosts = [\"photoshop\"]\n    families = [\"workfile\"]\n    optional = True\n\n    def process(self, instance):\n        errored_plugins = get_errored_plugins_from_context(instance.context)\n        if errored_plugins:\n            raise RuntimeError(\n                \"Skipping incrementing current file because publishing failed.\"\n            )\n\n        scene_path = version_up(instance.context.data[\"currentFile\"])\n        _, ext = os.path.splitext(scene_path)\n        photoshop.stub().saveAs(scene_path, ext[1:], True)\n\n        self.log.info(\"Incremented workfile to: {}\".format(scene_path))\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/validate_instance_asset.html","title":"validate_instance_asset","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/validate_instance_asset.html#client.ayon_photoshop.plugins.publish.validate_instance_asset.ValidateInstanceAsset","title":"<code>ValidateInstanceAsset</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Validate the instance folder is the current selected context folder.</p> <p>As it might happen that multiple worfiles are opened, switching between them would mess with selected context. In that case outputs might be output under wrong folder!</p> <p>Repair action will use Context folder value (from Workfiles or Launcher) Closing and reopening with Workfiles will refresh  Context value.</p> Source code in <code>client/ayon_photoshop/plugins/publish/validate_instance_asset.py</code> <pre><code>class ValidateInstanceAsset(OptionalPyblishPluginMixin,\n                            pyblish.api.InstancePlugin):\n    \"\"\"Validate the instance folder is the current selected context folder.\n\n    As it might happen that multiple worfiles are opened, switching\n    between them would mess with selected context.\n    In that case outputs might be output under wrong folder!\n\n    Repair action will use Context folder value (from Workfiles or Launcher)\n    Closing and reopening with Workfiles will refresh  Context value.\n    \"\"\"\n\n    label = \"Validate Instance Folder\"\n    hosts = [\"photoshop\"]\n    optional = True\n    actions = [ValidateInstanceFolderRepair]\n    order = ValidateContentsOrder\n\n    def process(self, instance):\n        instance_folder_path = instance.data[\"folderPath\"]\n        current_folder_path = get_current_folder_path()\n\n        if instance_folder_path != current_folder_path:\n            msg = (\n                f\"Instance folder {instance_folder_path} is not the same\"\n                f\" as current context {current_folder_path}.\"\n\n            )\n            repair_msg = (\n                \"Repair with 'Repair' button\"\n                f\" to use '{current_folder_path}'.\\n\"\n            )\n            formatting_data = {\"msg\": msg,\n                               \"repair_msg\": repair_msg}\n            raise PublishXmlValidationError(self, msg,\n                                            formatting_data=formatting_data)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/validate_instance_asset.html#client.ayon_photoshop.plugins.publish.validate_instance_asset.ValidateInstanceFolderRepair","title":"<code>ValidateInstanceFolderRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the instance folder.</p> Source code in <code>client/ayon_photoshop/plugins/publish/validate_instance_asset.py</code> <pre><code>class ValidateInstanceFolderRepair(pyblish.api.Action):\n    \"\"\"Repair the instance folder.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n\n        # Get the errored instances\n        failed = []\n        for result in context.data[\"results\"]:\n            if (\n                result[\"error\"] is not None\n                and result[\"instance\"] is not None\n                and result[\"instance\"] not in failed\n            ):\n                failed.append(result[\"instance\"])\n\n        # Apply pyblish.logic to get the instances for the plug-in\n        instances = pyblish.api.instances_by_plugin(failed, plugin)\n        stub = photoshop.stub()\n        current_folder_path = get_current_folder_path()\n        for instance in instances:\n            data = stub.read(instance[0])\n            data[\"folderPath\"] = current_folder_path\n            stub.imprint(instance[0], data)\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/validate_naming.html","title":"validate_naming","text":""},{"location":"autoapi/client/ayon_photoshop/plugins/publish/validate_naming.html#client.ayon_photoshop.plugins.publish.validate_naming.ValidateNaming","title":"<code>ValidateNaming</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate the instance name.</p> <p>Spaces in names are not allowed. Will be replace with underscores.</p> Source code in <code>client/ayon_photoshop/plugins/publish/validate_naming.py</code> <pre><code>class ValidateNaming(pyblish.api.InstancePlugin):\n    \"\"\"Validate the instance name.\n\n    Spaces in names are not allowed. Will be replace with underscores.\n    \"\"\"\n\n    label = \"Validate Naming\"\n    hosts = [\"photoshop\"]\n    order = ValidateContentsOrder\n    families = [\"image\"]\n    actions = [ValidateNamingRepair]\n\n    # configured by Settings\n    invalid_chars = ''\n    replace_char = ''\n\n    def process(self, instance):\n        help_msg = ' Use Repair button to fix it and then refresh publish.'\n\n        layer = instance.data.get(\"layer\")\n        if layer:\n            msg = \"Name \\\"{}\\\" is not allowed.{}\".format(\n                layer.clean_name, help_msg\n            )\n            formatting_data = {\"msg\": msg}\n            if re.search(self.invalid_chars, layer.clean_name):\n                raise PublishXmlValidationError(\n                    self, msg, formatting_data=formatting_data\n                )\n\n        product_name = instance.data[\"productName\"]\n        msg = \"Product \\\"{}\\\" is not allowed.{}\".format(\n            product_name, help_msg\n        )\n        formatting_data = {\"msg\": msg}\n        if re.search(self.invalid_chars, product_name):\n            raise PublishXmlValidationError(\n                self, msg, formatting_data=formatting_data\n            )\n\n    @classmethod\n    def get_replace_chars(cls):\n        \"\"\"Pass values configured in Settings for Repair.\"\"\"\n        return cls.invalid_chars, cls.replace_char\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/validate_naming.html#client.ayon_photoshop.plugins.publish.validate_naming.ValidateNaming.get_replace_chars","title":"<code>get_replace_chars()</code>  <code>classmethod</code>","text":"<p>Pass values configured in Settings for Repair.</p> Source code in <code>client/ayon_photoshop/plugins/publish/validate_naming.py</code> <pre><code>@classmethod\ndef get_replace_chars(cls):\n    \"\"\"Pass values configured in Settings for Repair.\"\"\"\n    return cls.invalid_chars, cls.replace_char\n</code></pre>"},{"location":"autoapi/client/ayon_photoshop/plugins/publish/validate_naming.html#client.ayon_photoshop.plugins.publish.validate_naming.ValidateNamingRepair","title":"<code>ValidateNamingRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the instance folder.</p> Source code in <code>client/ayon_photoshop/plugins/publish/validate_naming.py</code> <pre><code>class ValidateNamingRepair(pyblish.api.Action):\n    \"\"\"Repair the instance folder.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n    settings_category = \"photoshop\"\n\n    def process(self, context, plugin):\n\n        # Get the errored instances\n        failed = []\n        for result in context.data[\"results\"]:\n            if (\n                result[\"error\"] is not None\n                and result[\"instance\"] is not None\n                and result[\"instance\"] not in failed\n            ):\n                failed.append(result[\"instance\"])\n\n        invalid_chars, replace_char = plugin.get_replace_chars()\n        self.log.debug(\"{} --- {}\".format(invalid_chars, replace_char))\n\n        # Apply pyblish.logic to get the instances for the plug-in\n        instances = pyblish.api.instances_by_plugin(failed, plugin)\n        stub = photoshop.stub()\n        for instance in instances:\n            self.log.debug(\"validate_naming instance {}\".format(instance))\n            current_layer_state = stub.get_layer(instance.data[\"layer\"].id)\n            self.log.debug(\"current_layer{}\".format(current_layer_state))\n\n            layer_meta = stub.read(current_layer_state)\n            instance_id = (layer_meta.get(\"instance_id\") or\n                           layer_meta.get(\"uuid\"))\n            if not instance_id:\n                self.log.warning(\"Unable to repair, cannot find layer\")\n                continue\n\n            layer_name = re.sub(invalid_chars,\n                                replace_char,\n                                current_layer_state.clean_name)\n            layer_name = stub.PUBLISH_ICON + layer_name\n\n            stub.rename_layer(current_layer_state.id, layer_name)\n\n            product_name = re.sub(invalid_chars, replace_char,\n                                 instance.data[\"productName\"])\n\n            # format from Tool Creator\n            product_name = re.sub(\n                \"[^{}]+\".format(PRODUCT_NAME_ALLOWED_SYMBOLS),\n                \"\",\n                product_name\n            )\n\n            layer_meta[\"productName\"] = product_name\n            stub.imprint(instance_id, layer_meta)\n\n        return True\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.PhotoshopSettings","title":"<code>PhotoshopSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Photoshop Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class PhotoshopSettings(BaseSettingsModel):\n    \"\"\"Photoshop Project Settings.\"\"\"\n\n    imageio: PhotoshopImageIOModel = SettingsField(\n        default_factory=PhotoshopImageIOModel,\n        title=\"OCIO config\"\n    )\n\n    create: PhotoshopCreatorPlugins = SettingsField(\n        default_factory=PhotoshopCreatorPlugins,\n        title=\"Creator plugins\"\n    )\n\n    publish: PhotoshopPublishPlugins = SettingsField(\n        default_factory=PhotoshopPublishPlugins,\n        title=\"Publish plugins\"\n    )\n\n    workfile_builder: WorkfileBuilderPlugin = SettingsField(\n        default_factory=WorkfileBuilderPlugin,\n        title=\"Workfile Builder\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html","title":"creator_plugins","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.PhotoshopSettings","title":"<code>PhotoshopSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Photoshop Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class PhotoshopSettings(BaseSettingsModel):\n    \"\"\"Photoshop Project Settings.\"\"\"\n\n    imageio: PhotoshopImageIOModel = SettingsField(\n        default_factory=PhotoshopImageIOModel,\n        title=\"OCIO config\"\n    )\n\n    create: PhotoshopCreatorPlugins = SettingsField(\n        default_factory=PhotoshopCreatorPlugins,\n        title=\"Creator plugins\"\n    )\n\n    publish: PhotoshopPublishPlugins = SettingsField(\n        default_factory=PhotoshopPublishPlugins,\n        title=\"Publish plugins\"\n    )\n\n    workfile_builder: WorkfileBuilderPlugin = SettingsField(\n        default_factory=WorkfileBuilderPlugin,\n        title=\"Workfile Builder\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.CollectColorCodedInstancesPlugin","title":"<code>CollectColorCodedInstancesPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Set color for publishable layers, set its resulting product type    and template for product name.  Can create flatten image from published    instances.    (Applicable only for remote publishing!)</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class CollectColorCodedInstancesPlugin(BaseSettingsModel):\n    \"\"\"Set color for publishable layers, set its resulting product type\n    and template for product name. \\n Can create flatten image from published\n    instances.\n    (Applicable only for remote publishing!)\"\"\"\n\n    enabled: bool = SettingsField(True, title=\"Enabled\")\n    create_flatten_image: str = SettingsField(\n        \"\",\n        title=\"Create flatten image\",\n        enum_resolver=lambda: create_flatten_image_enum,\n    )\n\n    flatten_product_name_template: str = SettingsField(\n        \"\",\n        title=\"Product name template for flatten image\"\n    )\n\n    color_code_mapping: list[ColorCodeMappings] = SettingsField(\n        title=\"Color code mappings\",\n        default_factory=ColorCodeMappings,\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.CollectReviewPlugin","title":"<code>CollectReviewPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Should review product be created</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class CollectReviewPlugin(BaseSettingsModel):\n    \"\"\"Should review product be created\"\"\"\n    enabled: bool = SettingsField(True, title=\"Enabled\")\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.CollectVersionPlugin","title":"<code>CollectVersionPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Synchronize version for image and review instances by workfile version</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class CollectVersionPlugin(BaseSettingsModel):\n    \"\"\"Synchronize version for image and review instances by workfile version\"\"\"  # noqa\n    enabled: bool = SettingsField(True, title=\"Enabled\")\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ExtractImagePlugin","title":"<code>ExtractImagePlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Currently only jpg and png are supported</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ExtractImagePlugin(BaseSettingsModel):\n    \"\"\"Currently only jpg and png are supported\"\"\"\n    formats: list[str] = SettingsField(\n        title=\"Extract Formats\",\n        default_factory=list,\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateNamingPlugin","title":"<code>ValidateNamingPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Validate naming of products and layers</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateNamingPlugin(BaseSettingsModel):\n    \"\"\"Validate naming of products and layers\"\"\"  # noqa\n    invalid_chars: str = SettingsField(\n        '',\n        title=\"Regex pattern of invalid characters\"\n    )\n\n    replace_char: str = SettingsField(\n        '',\n        title=\"Replacement character\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/workfile_builder.html","title":"workfile_builder","text":""}]}